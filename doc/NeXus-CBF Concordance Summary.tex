\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{url}
\usepackage{amsmath}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{NeXus-CBF Concordance Summary}

\author{Herbert J. Bernstein, Aaron S. Brewster, Daniel Paley, Tobias S. Richter, Jonathan Sloan}
\date{4 June 2025}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
\onecolumn
\tableofcontents
\newpage

\section{Introduction}

This is an updated concordance of the representation of macromolecular crystallographic
image data when presented in NeXus/HDF5 or CBF/imgCIF.  The original version written
by Herbert J. Bernstein, Tobias S. Richter, and Jonathan Sloan was released
in August 2013 \cite{bernstein2013managing}, shortly after release of Dectris Eiger detectors using NeXus/HDF5 and six
years after the adoption of CBF/imgCIF for Dectris Pilatus detectors in 2007.  As of
this writing both image formats are still in widespread use, and comversion between them
is a common part of light source workflows.

As of this writing in 2025, the primary reference ontology for coordinate data for macromolecular
crystallography is the Protein Data Bank's PDBX/mmCIF dictionary \cite{westbrook2022pdbx},
and the primary reference ontology for raw crystallographic diffraction image data
is the CBF/imgCIF dictionary \cite{bernstein20062} now housed in the DIALS cbflib github
repository \footnote{\url{http://github.com/dials/cbflib}}.  The most commonly used container
other than CBF/imgCIF for macromolecular crystallographic image data is NeXus/HDF5
\cite{konnecke2015nexus} using the Dectris Filewriter format as described in the
Gold Standard paper \cite{bernstein2020gold}.  NeXus is tree-oriented and imgCIF/CBF is table-oriented.  
In this document we summarize an approach to a concordance between them.  Both 
frameworks allow for multiple alternative 
representations of the same data.  HDF5 provides a particularly appropriate format
for the management of large numbers of experimental data sets and for the representation
of particularly large data sets.

                                                                                                                                                                                                                                        

The original concordance in 2013 combined input from Herbert J. Bernstein, Tobias S. Richter and Jonathan Sloan,
as well as comments and suggestions by Mark Koennecke in 2010
(see \url{http://lists.nexusformat.org/pipermail/nexus-developers/attachments/20100201/a9424156/attachment-0001.el})
and by the members of NIAC.

This draft is by Herbert J. Bernstein, Aaron Brester and Dan Paley, who take complete responsibility for any
mistakes and misunderstandings in this version.  Please send comments,
corrections and suggestions to \url{yayahjb@gmail.com}.

The reader is assumed to already have familiarity with imgCIF/CBF, NeXus and HDF5.

\section{How to read this document}

While the mappings described here are complex and detailed, the approaches to the
mappings are simple.  If you are familiar with both CBF and NeXus, you should
read section~\ref{Mapping from CBF to NeXus} ``Mapping from CBF to NeXus'' 
on page \pageref{Mapping from CBF to NeXus}
through ``Identifying images'' on page \pageref{Identifying images} and
section~\ref{Mapping from NeXus to CBF/imgCIF} ``Mapping from NeXus to CBF/imgCIF'' 
on page \pageref{Mapping from NeXus to CBF/imgCIF}
through ``Mapping Fields'' on page \pageref{Mapping Fields}.  If you are interested
on the handling of the Dectris Eiger detector, see 
section~\ref{Proposed Pixel Array Detector Application Definitions} 
``Proposed Pixel Array Detector Application Definitions''
on page \pageref{Proposed Pixel Array Detector Application Definitions}




\section{General Mapping Issues}
\label{General Mapping Issues}

A CBF is organized as a set of relational tables, each table is called a ``category''.
The name of a category is essentially the name of a class.  Categories are organized
into ``data blocks'' the name of a category must be distinct from the name of all
other categories in the same data block.  As a relational table, each table has a
key.  One component of the key is, in general, an "ID".

A NeXus file is organized as a tree.   Each node of the tree has a name, which
must be distinct from all the other names of nodes that are children of the
same parent, each node of the tree is an HDF5 NeXus class instance or an HDF5 dataset or
an HDF5 attribute.  Each NeXus class instance has a NeXus class.

In most cases the value of the ID in each row of a CBF table will have to be mapped
to the name of a NeXus class instance in the NeXus file, and in most cases the name of a NeXus class instance in
a NeXus file will have to be mapped to the value of an ID in some CBF table.

To avoid namespace conflicts, in going from CBF to NeXus, we carry the CBF category name 
prefixed by ``CBF\_'' along with the
ID value in ``dotted'' notation, using a double underscore, ``\_\_'', in place
of the period to conform to NeXus naming conventions, but so as to not
convict with the use of the single underscore, ``\_'', to separate components
of names on a single hierarchical level.  In going from NeXus to CBF, we strip 
leading dotted notation name components that match the target category name.

Similar considerations will arise throughout this mapping.  The major exception is
for the fields in NXdetector, in which the well-established practice in NeXus is to give
those fields fixed names, such as ``data''.  If there is no possibility of a name conflict,
we will retain the standard name and uses suffixes, rather than prefixes in cases that
require disambiguation.  In the longer term, it would be best to ensure reliable 
identification of the function of fields with attributes, rather than by name.  In
each case, an attribute will be added for that purpose.

Most CBF categories accept identifiers for variants.  NeXus does not have an equivalent
concept to variants at this time.

CBF carries detailed information about the storage of images, such as the compression
used, that is not exposed in NeXus.  That information is carried in HDF5.

CBF is designed to organize scans, identified by a scan ID, SCANID, in the context of multiple
scans per diffraction experiment, where each diffraction experiment is identified by a diffraction
ID, DIFFRNID, in the context of multiple experiments per study of a macromolecule, where each
macromolecular study is identified by an entry ID, ENTRYID.  This creates a 3-level hierarchy
of information supporting the eventual report and structural deposition.  At present, NeXus,
does not support an equivalent of this hierarchy.  This issue should be discussed. 

\section{Mapping from CBF to NeXus}
\label{Mapping from CBF to NeXus}

For the following mapping, where a placement current defined NeXus class instances under 
NXentry has not yet been specified the mapping is shown as ``$\rightarrow$ ??'', 
but all CBF items have a mapping under an CBF\_cbf NeXus class instance that we propose to place under NXentry,
so further mapping could be done entirely in NeXus or HDF5, if desired.
Each \_CATEGORY.COLUMN value of type CBFTYPE in row NN in data block DATABLOCK 
is mapped to 

\begin{verbatim}
        /entry__ENTRYID:NXentry 
            /CBF_cbf:CBF_cbf 
                /DATABLOCK:CBF_cbfdb 
                    /CATEGORY:CBF_cbfcat 
                        /COLUMN:CBF_cbfcol 
                            /NN 
                                /value
\end{verbatim}%

\noindent{}with the attribute @cbftype=CBFTYPE, so no information will be lost, and all the
information in the rest of the NeXus tree will be available in these relational tables.  For
most traditional NeXus uses of the file, these tables may be ignored or deleted, but they
are needed for efficient external management of multiple files in the context of a
larger data management system.  When very large numbers of datasets have to be handled
at a facility, standard practice is to put information on which searches will be
done into a relational database.  CBF tables are such information.  Translating them
faithfully into NeXus allows that information to preserved with the NeXus/HDF5 files,
rather than having to deal with two different file formats for this information.
In order to index information from a NeXus file into a database, as is done,
for example in the iCAT project, first the information needs to be in the
NeXus file.  Until the CBF to NeXus mapping has become complete and automatic,
the extra CBF\_cbf class ensures that all the information is available for such
database use.

\subsection{The NeXus Structure Into Which to Map}
\label{The NeXus Structure Into Which to Map}


The following is the target tree structure. All elements of this mapping 
should be carefully considered and discussed.   The attribute and field
names with CBF category name prefixes are potential placeholder for
shorter more readable names to be discussed.  Names with double asterisks
are flagged as particularly worth discussing.

\footnotesize{\begin{verbatim}
    /CBF_diffrn_scan__SCANID:NXentry
      /CBF_scan_id="SCANID"
      /CBF_diffrn_id="DIFFRNID"
      /CBF_entry_id="ENTRYID"
      /instrument:NXinstrument
        /CBF_diffrn_detector__DETECTORNAME:NXdetector
          /start_time=STARTDATETIME
          /end_time=ENDDATETIME
          /CBF_diffrn_scan_frame__date=DATES
          /CBF_diffrn_scan_frame__frame_id=IDS
          /average_count_time=AVGCOUNTTIME
            /@units="sec"
          /average_frame_restart_time=RSTRTTIME
            /@units="sec" 
          /average_frame_time=TIMEPER
            /@units="sec" 
          /count_time=COUNTTIMES
            /@units="sec"
          /frame_time=TIMEPERS
            /@units="sec" 
          /frame_restart_time=RSTRTTIME
            /@units="sec" 
          /frame_start_number=FRAMESTARTNO
          /frame_end_number=FRAMEENDNO
          /distance --> /NXentry/NXinstrument/NXsample/CBF_diffrn_measurement__sample_detector_distance
          /data_ARRAYID_BINARYID=DATA
            /@CBF_array_id="ARRAYID"
            /@CBF_binary_id="BINARYID"
            /@CBF_header_contents="HEADER"
            /@CBF_header_convention="HEADERCONVENTION"
            /@x_pixel_size=XPSIZE
            /@y_pixel_size=YPSIZE
            /@CBF_array_intensities__details="DETAILS"
            /@CBF_array_intensities__gain=GAIN
            /@CBF_array_intensities__gain_esd=GAINESD
            /@CBF_array_intensities__linearity="LINEARITY"
            /@CBF_array_intensities__offset=OFFSET
            /@CBF_array_intensities__scaling=SCALING
            /@CBF_array_intensities__overload=OVERLOAD
            /@CBF_array_intensities__undefined_value=UNDEFVAL
            /@CBF_array_intensities__pixel_fast_bin_size=FBINSIZE
            /@CBF_array_intensities__pixel_slow_bin_size=SBINSIZE
            /@CBF_array_intensities__pixel_binning_method="METHOD"
          /deadtime=DTIME
          /description=DESCRIPTION
          /details=DETAILS
          /number_of_axes=NUMDETAXES
          /type=TYPE
        
          /CBF_array_structure_list__AXISSET1=[]
            /@CBF_array_id="ARRAYID"
            /@CBF_array_structure_list__dimension=DIM1
            /@CBF_array_structure_list__direction="DIR1"
            /@CBF_array_structure_list__index=1
            /@CBF_axis=PRECEDENCE1
          /CBF_array_structure_list__AXISSET2=[]
            /@CBF_array_id="ARRAYID"
            /@CBF_array_structure_list__dimension=DIM2
            /@CBF_array_structure_list__direction="DIR2"
            /@CBF_array_structure_list__index=2
            /@CBF_axis=PRECEDENCE2
          /CBF_array_structure_list_section__SECTIONID=[]
            /@CBF_array_id="ARRAYID"
            /@CBF_array_structure_list_section__index=INDEX
            /@CBF_array_structure_list_section__end=END
            /@CBF_array_structure_list_section__start=START
            /@CBF_array_structure_list_section__stride=STRIDE
          /CBF_array_structure_list_axis__AXISID=[]          **
            /@CBF_array_structure_list_axis__axis_id="AXISID"          **
            /@CBF_array_structure_list_axis__axis_set_id="AXISSETID"   **
            /@CBF_array_structure_list_axis__angle=ANGLE               **
            /@CBF_array_structure_list_axis__angle_increment=ANGLEINC  **
            /@CBF_array_structure_list_axis__displacement=DISP         **
            /@CBF_array_structure_list_axis__displacement=FRACTDISP    **
            /@CBF_array_structure_list_axis__fract_displacement=DISPINC **
            /@CBF_array_structure_list_axis__fract_displacement_increment=FRACTINC **
            /@CBF_array_structure_list_axis__angular_pitch=ANGPITCH    **
            /@CBF_array_structure_list_axis__radial_pitch=RADPITCH     **
            /@CBF_array_structure_list_axis__reference_angle=REFANG    **
            /@CBF_array_structure_list_axis__reference_displacement=REFDISP **
          /CBF_diffrn_scan_axis__AXISID=[]   
             /@CBF_axis_id="AXISID"                                       **
             /@CBF_diffrn_scan_axis__angle_start=ANGSTART
             /@CBF_diffrn_scan_axis__angle_range=ANGRANGE
             /@CBF_diffrn_scan_axis__angle_increment=ANGINC
             /@CBF_diffrn_scan_axis__angle_rstrt_incr=ANGRSTRT
             /@CBF_diffrn_scan_axis__displacement_start=DISPSTART
             /@CBF_diffrn_scan_axis__displacement_range=DISPRANGE
             /@CBF_diffrn_scan_axis__displacement_increment=DISPINC
             /@CBF_diffrn_scan_axis__displacement_rstrt_incr=DISPRSTRT
             /@CBF_diffrn_scan_axis__reference_angle=ANG
             /@CBF_diffrn_scan_axis__reference_displacement=DISP
          /CBF_diffrn_detector_element__id="ELEMENTID1:ELEMENTID2:..."      **
          /CBF_diffrn_detector_element__reference_center_fast=[RCF1,RCF2,...] **
          /CBF_diffrn_detector_element__reference_center_slow=[RCS1,RCS2,...] **
          /CBF_diffrn_detector_element__id="UNITS1:UNITS2:..." **
          /CBF_diffrn_data_frame__section_id=SECTIONIDARRAY **
          /CBF_diffrn_data_frame__binary_id=BINARYIDARRAY  **
          /CBF_diffrn_data_frame__center_fast_slow=CENTERARRAY **
            /@units="UNITS"
          /CBF_diffrn_data_frame__details=DETAILSARRAY
        
        /CBF_diffrn_measurement__GONIOMETER:NXsample
          /CBF_diffrn_measurement__details="DETAILS"
          /CBF_diffrn_measurement__device="DEVICE"
          /CBF_diffrn_measurement__device_details="DEVDETAILS"
          /CBF_diffrn_measurement__device_type="DEVTYPE"
          /CBF_diffrn_measurement__method="METHOD"
          /number_of_axes=NUMBER
          /CBF_diffrn_measurement__sample_detector_distance=DIST 
            /@units="mm"
          /CBF_diffrn_measurement__sample_detector_voffset=VOFST 
            /@units="mm"
          /CBF_diffrn_measurement__specimen_support="SPECSPRT"
          /CBF_diffrn_radiation__collimation="COLLIMATION"
          /divergence_x=DIVX
            /@units="deg"
          /divergence_y=DIVY
            /@units="deg"
          /CBF_diffrn_radiation__div_x_y_source=DIVXY 
            /@units="deg^2"
          /CBF_diffrn_radiation__filter_edge=ABSEDGE 
            /@units="angstroms"
          /CBF_diffrn_radiation__inhomogeneity=HWIDTH 
            /@units="mm"
            
        /monochromator:NXmonochromator 
          /wavelength=WAVELENGTH
          /CBF_diffrn_radiation__monochromator="MONOCHROMATOR" 
          /CBF_diffrn_radiation__polarisn_norm=POLNANG 
            /@units="deg"
          /CBF_diffrn_radiation__polarisn_ratio=POLRAT
          /CBF_diffrn_radiation__polarizn_source_norm=POLSNANG
            /@units="deg"
          /CBF_diffrn_radiation__polarizn_source_ratio=POLSRAT
          /CBF_diffrn_radiation__probe="RADIATION"
          /CBF_diffrn_radiation__type="SIEGBAHNTYPE"
          /CBF_diffrn_radiation__xray_symbol="IUPACXRAYSYMB"
        /CBF_diffrn_scan_SCANID:NXscan
        /CBF_diffrn_scan_frame_monitor__DETECTORNAME:NXmonitor
          /data=MONITORVALUES
          /count_time=INTEGRATIONTIMES
            /@units="sec"
                
\end{verbatim}}

In the years since the original proposal, NeXus has chosen to gather
the information about the various transformations based rotation,
translation, and general axes in one or more NXtranformations groups.

This is a fragmentary example of the axis definitions as proposed for
NeXus taken from the CBF fragment afterwards.

\footnotesize{\begin{verbatim}
       /instrument:NXinstrument
          /CBF_diffrn_detector__DETECTOR:NXdetector
             CBF_axis__DETECTOR_PITCH=[0.]
                @units="deg"
                @CBF_location="image_1.axis.vector.10"
                @depends_on="axis__DETECTOR_Y"
                @transformation_type="rotation"
                @vector=[-1, 0, 0]
             CBF_axis__DETECTOR_Y=[0.]
                @units="mm"
                @CBF_location="image_1.axis.vector.9"
                @depends_on="axis__DETECTOR_Z"
                @transformation_type="translation"
                @vector=[0, -1, 0]
             CBF_axis__DETECTOR_Z=[250.]
                @units="mm"
                @CBF_location="image_1.axis.vector.8"
                depends_on="."
                @transformation_type="translation"
                @vector= [0, 0, 1]
             CBF_axis__ELEMENT_X=[0.]
                @units="mm"
                @offset_units="mm"
                @CBF_location="image_1.axis.vector.11"
                @depends_on="axis__DETECTOR_PITCH"
                @transformation_type="translation"
                @vector= [-1, 0, 0]
                @offset= [-211.818, -217.322, 0]
             CBF_axis__ELEMENT_Y=[0.]
                @units="mm"
                @CBF_location=image_1.axis.vector.12
                @depends_on="axis__ELEMENT_X"
                @transformation_type="translation"
                @vector= [0, 1, 0]
          /CBF_coordinate_system:NXcoordinate_system
             /CBF_axis__SLS_X=[]
                @CBF__location="image_1.axis.vector.0"
                @depends_on="."
                @vector= [-1, 0, 0]
             /CBF_axis__SLS_Y=[]
                @CBF__location="image_1.axis.vector.1"
                @depends_on="."
                @vector= [0, -1, 0]
             /CBF_axis__SLS_Z=[]
                @CBF__location="image_1.axis.vector.2"
                @depends_on="."
                @vector= [0, 0, 1]
             /CBF_axis__GRAVITY=[]
                @cbf_location="image_1.axis.vector.7"
                @depends_on="."
                @vector=[0, -1, 0]
             /CBF_axis__BEAM=[]
                @cbf_location="image_1.axis.vector.6"
                @epends_on="."
                @vector= [0, 0, 1]
          /CBF_diffrn_measurement__GONIOMETER:NXsample   (Note:  Changed fron NXgoniometer, 8Aug13)
             /CBF_axis__GONIOMETER_KAPPA=[0]
                @units="deg"
                @CBF__location="image_1.axis.vector.4"
                @depends_on="axis__GONIOMETER_OMEGA"
                @transformation_type="rotation"
                @vector= [-0.64279, 0.76604, 0]
             /CBF_axis__GONIOMETER_OMEGA=[0]
                @units="deg"
                @CBF__location=image_1.axis.vector.3
                @depends_on="."
                @transformation_type="rotation"
                @vector= [1, 0, 0]
             /CBF_axis__GONIOMETER_PHI=[0]
                @units="deg"
                @CBF__location=image_1.axis.vector.5
                @depends_on="axis__GONIOMETER_KAPPA"
                @transformation_type="rotation"
                @vector= [1, 0, 0]
\end{verbatim}}

\footnotesize{\begin{verbatim}
loop_
_axis.id          #___
_axis.type        #___\___________
_axis.equipment   #___|___________\____________
_axis.depends_on  #___|___________|____________\______________
_axis.vector[1]   #___|___________|____________|______________\__
_axis.vector[2]   #___|___________|____________|______________|__\__
_axis.vector[3]   #___|___________|____________|______________|__|__\
_axis.offset[1]   #___|___________|____________|______________|__|__|___
_axis.offset[2]   #___|___________|____________|______________|__|__|___\__
_axis.offset[3]   #___|___________|____________|______________|__|__|___|__\__
                  #   |           |            |              |  |  |   |  |  \\
                  #   |           |            |              |  |  |   |  |  |
######################|###########|############|##############|##|##|###|##|##|
# The SLS Beamline axis convention is similar to the imgCIF convention, but   |
# Y and Z run the other way       |            |              |  |  |   |  |  |
######################|###########|############|##############|##|##|###|##|##|
#                     |           |            |              |  |  |   |  |  |
  SLS_X             general     general         .              1  0  0 0  0  0
  SLS_Y             general     general         .              0 -1  0 0  0  0
  SLS_Z             general     general         .              0  0 -1 0  0  0
#                     |           |            |              |  |  |   |  |  |
######################|###########|############|##############|##|##|###|##|##|
# We define a kappa geometry with a left-handed omega and phi and a right- |  |
# handed kappa.  The kappa axis arm is at the top when omega is zero    |  |  |
######################|###########|############|##############|##|##|###|##|##|
#                     |           |            |              |  |  |   |  |  |
  GONIOMETER_OMEGA  rotation    goniometer      .             -1  0  0  .  .  .
  GONIOMETER_KAPPA  rotation    goniometer      GONIOMETER_OMEGA
                                                         0.64279 0.76604
                                                                     0  .  .  .
  GONIOMETER_PHI    rotation    goniometer      GONIOMETER_KAPPA
                                                              -1  0  0  .  .  .
######################|###########|############|##############|##|##|###|##|##|
  BEAM              general     source          .              0  0 -1
.  .  .
  GRAVITY           general     gravity         .              0 -1  0
.  .  .
######################|###########|############|##############|##|##|###|##|##|
#                     |           |            |              |  |  |   |  |  |
######################|###########|############|##############|##|##|###|##|##|
# The detector is assumed to be mounted on an arm parallel to the beam     |  |
# with a DETECTOR_Y vertical translation and a pitch axis                  |  |
######################|###########|############|##############|##|##|###|##|##|
#                     |           |            |              |  |  |   |  |  |
  DETECTOR_Z        translation detector        .              0  0 -1  0  0  0
  DETECTOR_Y        translation detector        DETECTOR_Z     0 -1  0  0  0  0
  DETECTOR_PITCH    rotation    detector        DETECTOR_Y     1  0  0  0  0  0
######################|###########|############|##############|##|##|###|##|##|
# This detector is assumed to have the 0,0 corner at +X and -Y   |  |   |  |  |
# we assume a 2463 x 2527 detector on a 0.172 mm pixel pitch     |  |   |  |  |
######################|###########|############|##############|##|##|###|##|##|
#                     |           |            |              |  |  |   |  |  |
  ELEMENT_X         translation detector        DETECTOR_PITCH 1  0  0
                                                              211.818 -217.322 0
  ELEMENT_Y         translation detector        ELEMENT_X      0  1  0   0  0  0
\end{verbatim}}


\subsection{The NeXus top level}
\label{The NeXus top level}


The top level presented on the NeXus side of this mapping is 

\begin{verbatim}
    /CBF_diffrn_scan__SCANID:NXentry
\end{verbatim}

These scans can then be NeXus class instanceed into diffraction experiments and then
into macromolecular studies by careful organization of files in
tree of directories, but as the number of files and directories become
large and individual scans get moved, there is a serious risk
of loss of critical information if the identifiers for higher levels
of the hierarchy are not recoverable from individual scans.  For
this reason, the fields

\begin{verbatim}
  /CBF_scan_id="SCANID"
  /CBF_diffrn_id="DIFFRNID"
  /CBF_entry_id="ENTRYID"
\end{verbatim}

are given at the top level, if available, even if the same information is carried
deeper in the hierarchy. 
  

\subsection{Identifying images}
\label{Identifying images}

In many experimental disciplines, including X-ray crystallography, multiple
related images are generated a single experiment.  In some cases these
can be gathered into a single array, but there are also many cases in
which multiple data arrays are needed.  Therefore, it is not sufficient
to reserve the name ``data'' for the data.  In imgCIF and array of
data is identified by two identifiers, an array ID, specifying the
structure of the array, and a binary ID identifying a specific
array.  We name such data arrays by composing the commonly used
name ``data'' these two identifiers separated by an underscores ``\_''.

When only one array ID and only one binary ID are present, then it
will be sufficient to just use the field name ``data''.

It is important to note that an image from an single detector
may consist of only a slice (or ``section'') taken from a larger
array of data, and that a multi-element detector
may be stored either as a single slice from one array common to all the
elements, or as separate slices from different arrays, one array (or even
more than one array) per detector element.


\subsection{The ARRAY\_DATA category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_DATA category are the containers for
the array data items described in the category ARRAY_STRUCTURE.
    
It is recognized that the data in this category needs to be used in
two distinct ways.  During a data collection the lack of ancillary
data and timing constraints in processing data may dictate the
need to make a 'miniCBF' nothing more than an essential minimum
of information to record the results of the data collection.  In that
case it is proper to use the ARRAY_DATA category as a
container for just a single image and a compacted, beam-line
dependent list of data collection parameter values.  In such
a case, only the tags '_array_data.header_convention',
'_array_data.header_contents' and '_array_data.data' need be
populated.
    
For full processing and archiving, most of the tags in this
dictionary will need to be populated.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_DATA category is:

\begin{verbatim}     
    _array_data.array_id ARRAYID
    _array_data.binary_id BINARYID
    _array_data.data  DATAARRAY
    _array_data.header_contents HEADER
    _array_data.header_convention HEADERCONVENTION
\end{verbatim}
~~~~~~$\rightarrow$\\
\begin{verbatim}
   /entry:NXentry
     /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID
            @CBF_array_id="ARRAYID"
            @CBF_binary_id="BINARYID"
            @CBF_header_contents="HEADER"
            @CBF_header_convention="HEADERCONVENTION"
\end{verbatim}
}

\subsection{The ARRAY\_DATA\_EXTERNAL\_DATA category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_DATA_EXTERNAL_DATA category optionally
record the location and essential characteristics of arrays of data for use in 
ARRAY_DATA that are found external to the cif_img file.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_DATA\_EXTERNAL\_DATA category is:

\begin{verbatim}     
    _array_data.array_id ARRAYID
    _array_data.binary_id BINARYID
    _array_data.external_data_id EXTERNAL_DATA_ID
    _array_data.header_contents HEADER
    _array_data.header_convention HEADERCONVENTION

    _array_data_external_data.archive_format ARCHIVEFORMAT
    _array_data_external_data.archive_path ARCHIVEPATH
    _array_data_external_data.id EXTERNAL_DATA_ID
    _array_data_external_data.format HDF5
    _array_data_external_data.uri DATAURI
    _array_data_external_data.path DATAPATH
    _array_data_external_data.frame DATAFRAME
\end{verbatim}
~~~~~~$\rightarrow$\\
\begin{verbatim}
    /entry:NXentry
     /data_ARRAYID_BINARYID:NXdata
       data_ARRAYID_BINARYID --> DATAURI//DATAPATH
     /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID
            @CBF_array_id="ARRAYID"
            @CBF_binary_id="BINARYID"
            @CBF_header_contents="HEADER"
            @CBF_header_convention="HEADERCONVENTION"
            @CBF_external_data_archive_format="ARCHIVEFORMAT"
            @CBF_external_data_archive_path="ARCHIVEPATH""
            @CBF_external_data_uri="DATAURI"
            @CBF_external_data_path="DATAPATH"
            @CBF_external_data_frame="DATAFRAME"
\end{verbatim}
}

\subsection{The ARRAY\_ELEMENT\_SIZE category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_ELEMENT_SIZE category record the physical
size of array elements along each array dimension.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_ELEMENT\_SIZE category is:

\begin{verbatim}     
There is no general equivalent to ARRAY_ELEMENT_SIZE in NeXus, but for 
NXdetector_module, the pixel size is given as values in the array
fast_pixel_direction and slow_pixel_direction.
\end{verbatim}
}

\subsection{The ARRAY\_INTENSITIES category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_INTENSITIES category record the
information required to recover the intensity data from
the set of data values stored in the ARRAY_DATA category.

The detector may have a complex relationship
between the raw intensity values and the number of
incident photons.  In most cases, the number stored
in the final array will have a simple linear relationship
to the actual number of incident photons, given by
_array_intensities.gain.  If raw, uncorrected values
are presented (e.g. for calibration experiments), the
value of _array_intensities.linearity will be 'raw'
and _array_intensities.gain will not be used.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_DATA\_EXTERNAL\_DATA category is:

\begin{verbatim}     
    _array_intensities.array_id ARRAYID
    _array_intensities.binary_id BINARYID
    _array_intensities.details DETAILS
    _array_intensities.gain GAIN
    _array_intensities.gain_esd GAINESD
    _array_intensities.linearity LINEARITY
    _array_intensities.offset OFFSET
    _array_intensities.scaling SCALING
    _array_intensities.overload OVERLOAD
    _array_intensities.undefined_value UNDEFVAL
    _array_intensities.underload UNDERLOAD
    _array_intensities.pixel_fast_bin_size FBINSIZE
    _array_intensities.pixel_slow_bin_size SBINSIZE
    _array_intensities.pixel_binning_method METHOD
\end{verbatim}
~~~~~~$\rightarrow$\\
\begin{verbatim}
      /entry:NXentry
        /data_ARRAYID_BINARYID:NXdata
          /data_ARRAYID_BINARYID
              @CBF_array_id="ARRAYID"
              @CBF_binary_id="BINARYID"
              @details="DETAILS"
              @gain=[GAIN]     
              @gain_esd=[GAINESD]
              @linearity="LINEARITY"
              @offset=[OFFSET]
              @saturation_value=[OVERLOAD]
              @scaling_factor=[SCALING]
              @undefined_value=[UNDEFVAL]
              @underload_value=[UNDERLOAD]
              @CBF_array_intensities__pixel_fast_bin_size=[FBINSIZE]
              @CBF_array_intensities__pixel_slow_bin_size=[SBINSIZE]
              @CBF_array_intensities__pixel_binning_method="METHOD"
       /instrument:NXinstrument
         /DETECTORNAME:NXdetector_group
         /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID

The argument has been made that these attributes are not needed
because NeXus files are supposed to have 'true values' stored.
In many cases that is true and then none of these attributes
are needed.  However, with some detectors and some experiments
there are good technical and scientific reasons to bring in values
that will need processing later to derive 'true values', and in
those case some or all of these attributes will be needed.  They
are provided for such cases.

The same attributes could be used as fields in the case of a single
data array, but in that case links for all the fields would be needed
from NXdata to NXdetector, so it is preferable to use attributes even
in the case of a single data array.  The reverse mapping will support
both uses.
\end{verbatim}
}


\subsection{The ARRAY\_STRUCTURE category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY\_STRUCTURE category record the organization and
encoding of array data that may be stored in the ARRAY\_DATA category.

Note that this is essentially a type that may apply to multiple
binary images, and corresponds to some of the detailed HDF5
information about an array.   The following mapping is a placeholder
for the names given for future reference, if needed.

The information in this category is the byte order, the compression
information, and the encoding, which is carried in and retrievable
from the HDF5 types, properties lists, etc.  

At present NeXus does not expose this information.  This should be
discussed.
\end{verbatim}
}



\subsection{The ARRAY\_STRUCTURE\_LIST category}

{\footnotesize\begin{verbatim}
     Data items in the ARRAY_STRUCTURE_LIST category record the size
     and organization of each array dimension.

     The relationship to physical axes may be given.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_STRUCTURE\_LIST category is:

\begin{verbatim}     
    _array_structure_list.axis_set_id AXISSETID
    _array_structure_list.array_id ARRAYID 
    _array_structure_list.array_section_id ARRAYSECTIONID
    _array_structure_list.dimension DIM
    _array_structure_list.direction DIR
    _array_structure_list.index INDEX
    _array_structure_list.precedence PRECEDENCE
    
    _array_structure_list_section.array_id ARRAYID -->
    _array_structure_list_section.id ARRAYSECTIONID --> 
    _array_structure_list_section.index PRECEDENCE-->
    _array_structure_list_section.end END -->
    _array_structure_list_section.start START -->
    _array_structure_list_section.stride STRIDE -->
     
     loop_                         
    _array_structure_list_axis.axis_id
    _array_structure_list_axis.axis_set_id 
    _array_structure_list_axis.angle 
    _array_structure_list_axis.angle_increment
    _array_structure_list_axis.displacement
    _array_structure_list_axis.fract_displacement
    _array_structure_list_axis.displacement_increment 
    _array_structure_list_axis.fract_displacement_increment
    _array_structure_list_axis.angular_pitch
    _array_structure_list_axis.reference_angle
    _array_structure_list_axis.reference_displacement REFDISP
    AXISID1 AXISSETID ANGLE1 ANGLEINC1 DISP1 FRACTDISP1
         DISPINC1 FRACTINC1 ANGPITCH1 REFANG1
    AXISID2 AXISSETID ANGLE2 ANGLEINC2 DISP2 FRACTDISP2
         DISPINC2 FRACTINC2 ANGPITCH2 REFANG2
    AXISID3 AXISSETID ANGLE3 ANGLEINC3 DISP3 FRACTDISP3
         DISPINC3 FRACTINC3 ANGPITCH3 REFANG3

    _diffrn_data_frame.array_id ARRAYID
    _diffrn_data_frame.binary_id BINARYID
    _diffrn_data_frame.center_fast CENF
    _diffrn_data_frame.center_slow CENS
    _diffrn_data_frame.center_derived CENDERIVED
    _diffrn_data_frame.center_units UNITS
    _diffrn_data_frame.detector_element_id ELEMENTID
    _diffrn_data_frame.id FRAMEID
    _diffrn_data_frame.details DETAILS
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    ...

   /entry:NXentry
     /data_ARRAYID_BINARYID:NXdata
        @signal="data_ARRAYID_BINARY_ID"
        /data_ARRAYID_BINARYID[ the data for the array ARRAYID,
                                binary BINARYID, all sections,
                                all FRAMES]
        @axes=[...,AXISID1,...] with AXISID1 inserted at PRECEDENCE-1
        @AXISID1_indices=[PRECEDENCE-1]
        @AXISID2_indices=[PRECEDENCE-1]
        @AXISID3_indices=[PRECEDENCE-1]
        @AXISID1_origins=[origin1]  (default 0)
        @AXISID2_origins=[origin2]  (default 0)
        @AXISID3_origins=[origin3]  (default 0)
        @AXISID1_sizes=[size1]
        @AXISID2_sizes=[size2]
        @AXISID3_sizes=[size3]
        @AXISID1_strides=[stride1]
        @AXISID2_strides=[stride2]
        @AXISID3_strides=[stride3]

        ...
        /AXISID1 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID1
        /AXISID2 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID2
        /AXISID2 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID3
        ...

     /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID
           /AXISID1 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID1
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID2
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID3
           /ARRAYSECTIONID:NXdetector_module
             /data_origin=[...] -- the 0-based origins indices of ARRAYSECTIONID
             /data_size=[...] the sizes in pixels of ARRAYSECTIONID
             /data_stride[...] the strides of ARRAYSECTIONID
               ..
           /transformations:NXtransformations
             /AXISID1=[DISP1,DISP1+DISPINC1,...]
                  (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID1"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE1
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC1
                @CBF_array_structure_list_axis__displacement=DISP1
                @CBF_array_structure_list_axis__displacement=FRACTDISP1
                @CBF_array_structure_list_axis__displacement_increment=DISPINC1
                @CBF_array_structure_list_axis__fract_displacement_increment
                  =FRACTINC1
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH1
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH1
                @CBF_array_structure_list_axis__reference_angle=REFANG1
                @CBF_array_structure_list_axis__reference_displacement=REFDISP1
             /AXISID2=[DISP2,DISP2+DISPINC2,...]
                  (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID2"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE2
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC2
                @CBF_array_structure_list_axis__displacement=DISP2
                @CBF_array_structure_list_axis__displacement=FRACTDISP2
                @CBF_array_structure_list_axis__displacement_increment=DISPINC2
                @CBF_array_structure_list_axis__fract_displacement_increment
                  =FRACTINC2
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH2
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH2
                @CBF_array_structure_list_axis__reference_angle=REFANG2
                @CBF_array_structure_list_axis__reference_displacement=REFDISP2
             /AXISID3=[DISP3,DISP3+DISPINC3,...]
                  (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID3"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE3
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC3
                @CBF_array_structure_list_axis__displacement=DISP3
                @CBF_array_structure_list_axis__displacement=FRACTDISP3
                @CBF_array_structure_list_axis__displacement_increment=DISPINC3
                @CBF_array_structure_list_axis__fract_displacement_increment
                  =FRACTINC3
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH3
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH3
                @CBF_array_structure_list_axis__reference_angle=REFANG3
                @CBF_array_structure_list_axis__reference_displacement=REFDISP3

The same axis AXISIDn may appear in multiple axis sets for different
values of PRECEDENCE of the data array, in which case the values
in AXISIDn_indices will be the sorted list of PRECEDENCE-1 values
and the array section information will be organized by the
same ordering.
           
This mapping of precedence of axes and directions may seem redundant 
with the array storage parameters maintained by HDF5, but changed
information is used by applications to remap images to undo
rotations and flips and needs to be accessible without rewriting
the image, which may be impractical.  Failure to expose at least
this information in the NeXus will greatly restrict the range
of applications that will be able to use the NeXus version of
these files.

\end{verbatim}
}


\subsection{The ARRAY\_STRUCTURE\_LIST\_SECTION category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_STRUCTURE_LIST_SECTION category identify
the dimension-by-dimension start, end and stride of each section of an
array that is to be referenced.

For any array with identifier ARRAYID, array section ids of the form
ARRAYID(start1:end1:stride1,start2:end2:stride2, ...) are defined
by default.

For the given index, the elements in the section are of indices:
_array_structure_list_section.start,
_array_structure_list_section.start + _array_structure_list_section.stride,
_array_structure_list_section.start + 2*_array_structure_list_section.stride,
...

stopping either when the indices leave the limits of the indices
of that dimension or 
[min(_array_structure_list_section.start, _array_structure_list_section.end),
 max(_array_structure_list_section.start, _array_structure_list_section.end)].


The ordering of these elements is determined by the overall ordering of
_array_structure_list_section.array_id and not by the ordering implied
by the stride.

\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_STRUCTURE\_LIST\_SECTION
category is:

\begin{verbatim} 
    _array_structure_list_section.array_id ARRAYID -->
    _array_structure_list_section.id SECTIONID -->
    _array_structure_list_section.index INDEX-->
    _array_structure_list_section.end END -->
    _array_structure_list_section.start START -->
    _array_structure_list_section.stride STRIDE -->
    /instrument:NXinstrument       
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID
           /AXISID1 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID1
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID2 
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID3
           /ARRAYSECTIONID:NXdetector_module
             /data_origin=[...] -- the 0-based origins indices of ARRAYSECTIONID
             /data_size=[...] the sizes in pixels of ARRAYSECTIONID
             /data_stride[...] the strides of ARRAYSECTIONID
\end{verbatim}      
}

\subsection{The ARRAY\_STRUCTURE\_LIST\_AXIS category}

{\footnotesize\begin{verbatim}
Data items in the ARRAY_STRUCTURE_LIST_AXIS category describe
the physical settings of sets of axes for the centres of pixels that
correspond to data points described in the
ARRAY_STRUCTURE_LIST category.

In the simplest cases, the physical increments of a single axis correspond
to the increments of a single array index.  More complex organizations,
e.g. spiral scans, may require coupled motions along multiple axes.

Note that a spiral scan uses two coupled axes: one for the angular
direction and one for the radial direction.  This differs from a
cylindrical scan for which the two axes are not coupled into one 
set.

Axes may be specified either for an entire array or for just a section
of an array.
\end{verbatim}

The mapping from CBF into NeXus for the ARRAY\_STRUCTURE\_LIST\_AXIS category is:

\begin{verbatim}     
    _array_structure_list.axis_set_id AXISSETID
    _array_structure_list.array_id ARRAYID
    _array_structure_list.array_section_id ARRAYSECTIONID
    _array_structure_list.dimension DIM
    _array_structure_list.direction DIR 
    _array_structure_list.index INDEX
    _array_structure_list.precedence PRECEDENCE
       
    _array_structure_list_section.array_id ARRAYID -->
    _array_structure_list_section.id ARRAYSECTIONID -->
    _array_structure_list_section.index PRECEDENCE-->
    _array_structure_list_section.end END -->
    _array_structure_list_section.start START -->
    _array_structure_list_section.stride STRIDE -->
                
           
     loop_      
    _array_structure_list_axis.axis_id 
    _array_structure_list_axis.axis_set_id 
    _array_structure_list_axis.angle 
    _array_structure_list_axis.angle_increment 
    _array_structure_list_axis.displacement
    _array_structure_list_axis.fract_displacement
    _array_structure_list_axis.displacement_increment
    _array_structure_list_axis.fract_displacement_increment
    _array_structure_list_axis.angular_pitch
    _array_structure_list_axis.reference_angle
    _array_structure_list_axis.reference_displacement REFDISP
    AXISID1 AXISSETID ANGLE1 ANGLEINC1 DISP1 FRACTDISP1
         DISPINC1 FRACTINC1 ANGPITCH1 REFANG1
    AXISID2 AXISSETID ANGLE2 ANGLEINC2 DISP2 FRACTDISP2
         DISPINC2 FRACTINC2 ANGPITCH2 REFANG2
    AXISID3 AXISSETID ANGLE3 ANGLEINC3 DISP3 FRACTDISP3
         DISPINC3 FRACTINC3 ANGPITCH3 REFANG3

    _diffrn_data_frame.array_id ARRAYID
    _diffrn_data_frame.binary_id BINARYID
    _diffrn_data_frame.center_fast CENF
    _diffrn_data_frame.center_slow CENS
    _diffrn_data_frame.center_units UNITS
    _diffrn_data_frame.detector_element_id ELEMENTID
    _diffrn_data_frame.id FRAMEID
    _diffrn_data_frame.details DETAILS
\end{verbatim}
~~~~~~$\rightarrow$\\
\begin{verbatim}
    ...

   /entry:NXentry
     /data_ARRAYID_BINARYID:NXdata
        @signal="data_ARRAYID_BINARY_ID"
        /data_ARRAYID_BINARYID[ the data for the array ARRAYID,
                                binary BINARYID, all sections,
                                all FRAMES]
        @axes=[...,AXISID1,...] with AXISID1 inserted at PRECEDENCE-1
        @AXISID1_indices=[PRECEDENCE-1]
        @AXISID2_indices=[PRECEDENCE-1]
        @AXISID3_indices=[PRECEDENCE-1]
        @AXISID1_origins=[origin1]  (default 0)
        @AXISID2_origins=[origin2]  (default 0)
        @AXISID3_origins=[origin3]  (default 0)
        @AXISID1_sizes=[size1]
        @AXISID2_sizes=[size2]
        @AXISID3_sizes=[size3]
        @AXISID1_strides=[stride1]
        @AXISID2_strides=[stride2]
        @AXISID3_strides=[stride3]

        ...
        /AXISID1 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID1
        /AXISID2 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID2
        /AXISID2 -->
            /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID3
        ...

     /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
           /data_ARRAYID_BINARYID -->
                /entry/data_ARRAYID_BINARYID/data_ARRAYID_BINARYID
           /AXISID1 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID1
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID2
           /AXISID2 -->
                /entry/instrument/DETECTORELEMENTNAME/transformations/AXISID3
           /ARRAYSECTIONID:NXdetector_module
             /data_origin=[...] -- the 0-based origins indices of ARRAYSECTIONID
             /data_size=[...] the sizes in pixels of ARRAYSECTIONID
             /data_stride[...] the strides of ARRAYSECTIONID
               ..
           /transformations:NXtransformations
             /AXISID1=[DISP1,DISP1+DISPINC1,...]   (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID1"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE1
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC1
                @CBF_array_structure_list_axis__displacement=DISP1
                @CBF_array_structure_list_axis__displacement=FRACTDISP1
                @CBF_array_structure_list_axis__displacement_increment=DISPINC1
                @CBF_array_structure_list_axis__fract_displacement_increment=FRACTINC1
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH1
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH1
                @CBF_array_structure_list_axis__reference_angle=REFANG1
                @CBF_array_structure_list_axis__reference_displacement=REFDISP1
             /AXISID2=[DISP2,DISP2+DISPINC2,...]   (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID2"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE2
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC2
                @CBF_array_structure_list_axis__displacement=DISP2
                @CBF_array_structure_list_axis__displacement=FRACTDISP2
                @CBF_array_structure_list_axis__displacement_increment=DISPINC2
                @CBF_array_structure_list_axis__fract_displacement_increment=FRACTINC2
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH2
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH2
                @CBF_array_structure_list_axis__reference_angle=REFANG2
                @CBF_array_structure_list_axis__reference_displacement=REFDISP2
             /AXISID3=[DISP3,DISP3+DISPINC3,...]   (or using angles where appropriate)
                @depends_on=...   determined from AXIS definitions
                @equipment="detector"
                @offset=[...] determined from AXIS definitions
                @offset_units="mm"
                @transformation_type="..." from AXIS definitions
                @units="mm"
                @vector=[...] determined from AXIS definitions
                @CBF_array_structure_list_axis__axis_id="AXISID3"
                @CBF_array_structure_list_axis__axis_set_id="AXISSETID"
                @CBF_array_structure_list_axis__angle=ANGLE3
                @CBF_array_structure_list_axis__angle_increment=ANGLEINC3
                @CBF_array_structure_list_axis__displacement=DISP3
                @CBF_array_structure_list_axis__displacement=FRACTDISP3
                @CBF_array_structure_list_axis__displacement_increment=DISPINC3
                @CBF_array_structure_list_axis__fract_displacement_increment=FRACTINC3
                @CBF_array_structure_list_axis__angular_pitch=ANGPITCH3
                @CBF_array_structure_list_axis__radial_pitch=RADPITCH3
                @CBF_array_structure_list_axis__reference_angle=REFANG3
                @CBF_array_structure_list_axis__reference_displacement=REFDISP3

The same axis AXISIDn may appear in multiple axis sets for different
values of PRECEDENCE of the data array, in which case the values
in AXISIDn_indices will be the sorted list of PRECEDENCE-1 values
and the array section information will be organized by the
same ordering.
\end{verbatim}
}


\subsection{The AXIS category}

{\footnotesize \tt
Data items in the AXIS category record the information required
to describe the various goniometer, detector, source and other
axes needed to specify a data collection or the axes defining the
coordinate system of an image.
~~\\
The location of each axis is specified by two vectors: the axis
itself, given by a  unit vector in the direction of the axis, and
an offset to the base of the unit vector.
~~\\
The vectors defining an axis are referenced to an appropriate
coordinate system.  The axis vector, itself, is a dimensionless
unit vector.  Where meaningful, the offset vector is given in
millimetres.  In coordinate systems not measured in metres.
the offset is not specified and is taken as zero.
~~\\
The available coordinate systems are:\\
~~\\
    The imgCIF standard laboratory coordinate system\\
    The direct lattice (fractional atomic coordinates)\\
    The orthogonal Cartesian coordinate system (real space)\\
    The reciprocal lattice\\
    An abstract orthogonal Cartesian coordinate frame\\
~~\\
For consistency in this discussion, we call the three coordinate
system axes X, Y and Z.  This is appropriate for the imgCIF
standard laboratory coordinate system, and last two Cartesian
coordinate systems, but for the direct lattice, X corresponds
to a, Y to b and Z to c, while for the reciprocal lattice,
X corresponds to a*, Y to b* and Z to c*.\\
~~\\
For purposes of visualization, all the coordinate systems are
taken as right-handed, i.e., using the convention that the extended
thumb of a right hand could point along the first (X) axis, the
straightened pointer finger could point along the second (Y) axis
and the middle finger folded inward could point along the third (Z)
axis.  |\\
~~\\
THE IMGCIF STANDARD LABORATORY COORDINATE SYSTEM\\
~~\\
The imgCIF standard laboratory coordinate system is a right-handed
orthogonal coordinate similar to the MOSFLM coordinate system,
but imgCIF puts Z along the X-ray beam, rather than putting X along the
X-ray beam as in MOSFLM.\\
~~\\
The vectors for the imgCIF standard laboratory coordinate system
form a right-handed Cartesian coordinate system with its origin
in the sample or specimen.  The origin of the axis system should,
if possible, be defined in terms of mechanically stable axes to be
be both in the sample and in the beam.  If the sample goniometer or other
sample positioner has two axes the intersection of which defines a
unique point at which the sample should be mounted to be bathed
by the beam, that will be the origin of the axis system.  If no such
point is defined, then the midpoint of the line of intersection
between the sample and the center of the beam will define the origin.
For this definition the sample positioning system will be set at
its initial reference position for the experiment.\\
~~\\
~~\\
\verb.                           .| Y (to complete right-handed system)\\
\verb.                           .|\\
\verb.                           .|\\
\verb.                           .|\\
\verb.                           .|\\
\verb.                           .|\\
\verb.                           .|\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_X\\
\verb.                          ./\\
\verb.                         ./\\
\verb.                        ./\\
\verb.                       ./\\
\verb.                      ./\\
\verb.                     ./Z (to source)\\
~~\\
~~\\
Axis 1 (X): The X-axis is aligned to the mechanical axis pointing from
the sample or specimen along the  principal axis of the goniometer or
sample positioning system if the sample positioning system has an axis
that intersects the origin and which form an angle of more than 22.5
degrees with the beam axis.\\
~~\\
Axis 2 (Y): The Y-axis completes an orthogonal right-handed system
defined by the X-axis and the Z-axis (see below).\\
~~\\
Axis 3 (Z): The Z-axis is derived from the source axis which goes from
the sample to the source.  The Z-axis is the component of the source axis
in the direction of the source orthogonal to the X-axis in the plane
defined by the X-axis and the source axis.\\
~~\\
If the conditions for the X-axis can be met, the coordinate system
will be based on the goniometer or other sample positioning system
and the beam and not on the orientation of the detector, gravity etc.  
The vectors necessary to specify all other axes are given by sets of
three components in the order (X, Y, Z).
If the axis involved is a rotation axis, it is right-handed, i.e. as
one views the object to be rotated from the origin (the tail) of the
unit vector, the rotation is clockwise.  If a translation axis is
specified, the direction of the unit vector specifies the sense of
positive translation.\\
~~\\
Note:  This choice of coordinate system is similar to but significantly
different from the choice in MOSFLM \cite{leslie2007processing}.  In MOSFLM,
X is along the X-ray beam (the CBF/imgCIF Z axis) and Z is along the
rotation axis.\\
~~\\
In some experimental techniques, there is no goniometer or the principal
axis of the goniometer is at a small acute angle with respect to
the source axis.  In such cases, other reference axes are needed
to define a useful coordinate system.  The order of priority in
defining directions in such cases is to use the detector, then
gravity, then north.\\
~~\\
If the X-axis cannot be defined as above, then the
direction (not the origin) of the X-axis should be parallel to the axis
of the primary detector element corresponding to the most rapidly
varying dimension of that detector element's data array, with its
positive sense corresponding to increasing values of the index for
that dimension.  If the detector is such that such a direction cannot
be defined (as with a point detector) or that direction forms an
angle of less than 22.5 degrees with respect to the source axis, then 
the X-axis should be chosen so that if the Y-axis is chosen
in the direction of gravity, and the Z-axis is chosen to be along
the source axis, a right-handed orthogonal coordinate system is chosen. 
In the case of a vertical source axis, as a last resort, the
X-axis should be chosen to point North.\\
~~\\
All rotations are given in degrees and all translations are given in mm.\\
~~\\
Axes may be dependent on one another.  The X-axis is the only goniometer
axis the direction of which is strictly connected to the hardware.  All
other axes are specified by the positions they would assume when the
axes upon which they depend are at their zero points.\\
~~\\
When specifying detector axes, the axis is given to the beam centre.
The location of the beam centre on the detector should be given in the
DIFFRN\_DETECTOR category in distortion-corrected millimetres from
the (0,0) corner of the detector.\\
~~\\
It should be noted that many different origins arise in the definition
of an experiment.  In particular, as noted above, it is necessary to
specify the location of the beam centre on the detector in terms
of the origin of the detector, which is, of course, not coincident
with the centre of the sample.\\
~~\\
The unit cell, reciprocal cell and crystallographic orthogonal
Cartesian coordinate system are defined by the CELL and the matrices
in the ATOM\_SITES category.\\
~~\\
THE DIRECT LATTICE (FRACTIONAL COORDINATES)\\
~~\\
The direct lattice coordinate system is a system of fractional
coordinates aligned to the crystal, rather than to the laboratory.
This is a natural coordinate system for maps and atomic coordinates.
It is the simplest coordinate system in which to apply symmetry.
The axes are determined by the cell edges, and are not necessarily
orthogonal.  This coordinate system is not uniquely defined and
depends on the cell parameters in the CELL category and the
settings chosen to index the crystal.\\
~~\\
Molecules in a crystal studied by X-ray diffraction are organized
into a repeating regular array of unit cells.  Each unit cell is defined
by three vectors, a, b and c.  To quote from \cite{drenth2006introduction},\\
~~\\
``The choice of the unit cell is not unique and therefore, guidelines
have been established for selecting the standard basis vectors and
the origin.  They are based on symmetry and metric \\
considerations:\\
~~\\
``(1)  The axial system should be right handed.\\
(2)  The basis vectors should coincide as much as possible with
       directions of highest symmetry.\\
(3)  The cell taken should be the smallest one that satisfies|\\
(4)  Of all the lattice vectors, none is shorter than a.\\
(5)  Of those not directed along a, none is shorter than b.\\
(6)  Of those not lying in the ab plane, none is shorter than c.\\
(7)  The three angles between the basis vectors a, b and c are
either all acute (\tt{}< 90 degrees) or all obtuse (greater
than equal to 90 degrees).''\\
~~\\
These rules do not produce a unique result that is stable under
the assumption of experimental errors, and the the resulting cell
may not be primitive.\\     
~~\\     
In this coordinate system, the vector (.5, .5, .5) is in the middle
of the given unit cell.\\
~~\\     
Grid coordinates are an important variation on fractional coordinates
used when working with maps.  In imgCIF, the conversion from
fractional to grid coordinates is implicit in the array indexing
specified by \_array\_structure\_list.dimension.  Note that this
implicit grid-coordinate scheme is 1-based, not zero-based, {\it i.e.}
the origin of the cell for axes along the cell edges with no
specified \_array\_structure\_list\_axis.displacement will have
grid coordinates of (1,1,1), i.e. array indices of (1,1,1).\\
~~\\     
THE ORTHOGONAL CARTESIAN COORDINATE SYSTEM (REAL SPACE)\\
~~\\     
The orthogonal Cartesian coordinate system is a transformation of
the direct lattice to the actual physical coordinates of atoms in
space.  It is similar to the laboratory coordinate system, but
is anchored to and moves with the crystal, rather than being
anchored to the laboratory.  The transformation from fractional
to orthogonal cartesian coordinates is given by the \\
         \_atom\_sites.Cartn\_transf\_matrix[i][j]  and 
         \_atom\_sites.Cartn\_transf\_vector[i] 
tags.  A common choice for the matrix of the transformation is 
given in the 1992 PDB format document\\
~~\\
\[\begin{vmatrix}
               a & b \, cos(\gamma) & c \, cos(\beta) \\
               0 & b \, sin(\gamma) & c \, (cos(\alpha) - cos(\beta)cos(\gamma))/sin(\gamma)\\
               0 & 0               & V/( a\, b \, sin(\gamma)) \\
\end{vmatrix}
\]    
This is a convenient coordinate system in which to do fitting
of models to maps and in which to understand the chemistry of
a molecule.\\
~~\\     
THE RECIPROCAL LATTICE\\
~~\\     
The reciprocal lattice coordinate system is used for diffraction
intensities.  It is based on the reciprocal cell, the dual of the cell,
in which reciprocal cell edges are derived from direct cell faces:\\
~~\\     
        a$^*$ = bc sin($\alpha$)/V  b$^*$ = ac sin($\beta$)/V  c$^*$ = ab sin($\gamma$)/V\\
        cos($\alpha^*$) = (cos($\beta$) cos($\gamma$) - cos($\alpha$))/(sin($\beta$) sin($\gamma$))\\
        cos($\beta^*$) = (cos($\alpha$) cos($\gamma$) - cos($\beta$))/(sin($\alpha$) sin($\gamma$))\\
        cos($\gamma^*$) = (cos($\alpha$) cos(\b) - cos($\gamma$))/(sin($\alpha$) sin($\beta$))\\
        V = abc $\sqrt{(1 - cos(\alpha)^2 - cos(\beta)^2 - cos(\gamma)^2 + 2 cos(\alpha) cos(\beta) cos(\gamma) )}$\\
~~\\     
In this form the dimensions of the reciprocal lattice are in reciprocal
{\AA}ngstroms ({\AA}$^{-1}$).  A dimensionless form can be obtained by 
multiplying by the wavelength.  Reflections are commonly indexed against
this coordinate system as (h, k, l) triples.  See \cite{stout1989x} and \cite{PDB1992}.

The mapping from CBF into NeXus for the AXIS category is::
~~\\
\begin{verbatim}

    _axis.id                  AXISID
    _axis.type                AXISTYPE
    _axis.equipment           AXISEQUIPMENT
    _axis.equipment_component AXISEQUIPCOMP
    _axis.depends_on          AXISDEPENDSON
    _axis.rotation_axis       AXISROTAXIS
    _axis.rotation            AXISROTATION
    _axis.vector[1]           AXISV1
    _axis.vector[2]           AXISV2
    _axis.vector[3]           AXISV3
    _axis.offset[1]           AXISO1
    _axis.offset[2]           AXISO2
    _axis.offset[3]           AXISO3
    _axis.system              AXISSYSTEM

\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}

{     /entry:NXentry
        /instrument:NXinstrument
         /DETECTORELEMENTNAME:NXdetector
for AXISEQUIPMENT=="detector"}
{     /entry:NXentry
        /sample:NXsample
for AXISEQUIPMENT=="goniometer"}
{     /entry:NXentry
for AXISEQUIPMENT=="general"}
          /transformations:NXtransformations
            /AXISID=[]
              @units="mm"  if AXISTYPE=="translation" 
              or @units="degrees"  if AXISTYPE=="rotation"
              @transformation_type="AXISTYPE"
              @equipment_component="AXISEQUIPCOMP"
              @depends_on="AXISDEPENDSON"
              @rotation_axis="AXISROTAXIS"
              @rotation=AXISROTATION
              @rotation_units="degrees"
              @offset=offsetxform([O1,O2,O3])
              @offset_inits="mm"
              @vector=coordxform([V1,V2,V3])
\end{verbatim}


\begin{itemize}
\item{\_axis.system $\rightarrow$ \\
Only a laboratory coordinate system is handled in NeXus at present.
The addition of more coordinate systems in NeXus is pending.
See the discussion of transformation to the McStas coordinate system
below.  }

\item{\_axis.vector[1] V1 $\rightarrow$ \\
\verb|    |/CBF\_axis\_\_AXISID=[]\\
  @vector=coordxform([V1,V2,V3])}

\item{\_axis.vector[2] V2 $\rightarrow$ \\
\verb|    |/CBF\_axis\_\_AXISID=[]\\
  @vector=coordxform([V1,V2,V3])}

\item{\_axis.vector[3] V3 $\rightarrow$ \\
\verb|    |/CBF\_axis\_\_AXISID=[]\\
  @vector=coordxform([V1,V2,V3])}

\item{\_axis.variant $\rightarrow$ ??  NeXus does not handle variants at this time}
\end{itemize}


\subsubsection{Differences in Coordinate Frames}

The standard coordinate frame in NeXus is the McStas coordinate frame, in which the Z-axis
points in the direction of the incident beam, the X-axis is orthogonal to the Z-axis in the horizontal
plane and pointing left as seen from the source and the Y-axis points upwards.  The origin is in the
sample.

The standard coordinate frame in imgCIF/CBF aligns the X-axis to the principal goniometer axis,
chooses the Z-axis to point from the sample into the beam.  If the beam is not orthogonal
to the X-axis, the Z-axis is the component of the vector points into the beam orthogonal to the
X-axis.  The Y-axis is chosen to complete a right-handed axis system.

Let us call the NeXus coordinate axes, $\mathtt{X_{nx}}$, $\mathtt{Y_{nx}}$ and $\mathtt{Z_{nx}}$ and the imgCIF/CBF
coordinate axes, $\mathtt{X_{cbf}}$, $\mathtt{Y_{cbf}}$ and $\mathtt{Z_{cbf}}$ and the direction of gravity, $\mathtt{Gravity}$.  In order
to translate a vector $\mathtt{v_{nx} = \left( x, y, z \right)}$ from the NeXus coordinate system to the 
imgCIF coordinate system, we also need two additional axes, as unit vectors, $\mathtt{Gravity_{cbf}}$, 
the downwards direction, and  $\mathtt{Beam_{cbf}}$, the direction of the beam ({\it e.g.} $\left( 0, 0, -1\right)$).   

In practice, the beam is not necessarily perfectly horizontal, so $\mathtt{Y_{nx}}$ is not necessarily
perfectly vertical. Therefore, in order to generate $\mathtt{X_{nx}}$, $\mathtt{Y_{nx}}$ and $\mathtt{Z_{nx}}$ some care
is needed.  The cross product between two vectors $\overrightarrow{a}$ and $\overrightarrow{b}$ 
is a new vector $\overrightarrow{c}$ orthogonal to both   $\overrightarrow{a}$ and $\overrightarrow{b}$,
chosen so that $\overrightarrow{a}, \overrightarrow{b}, \overrightarrow{c}$ is a right handed system.
If $\overrightarrow{a}$ and $\overrightarrow{b}$ are orthogonal unit vectors, this right-handed system
is an orthonormal coordinate system.

In the CBF coordinate frame, $\mathtt{Z_{nx}}$ is aligned to $\mathtt{Beam_{cbf}}$:

\[ 
\mathtt{Z_{nx} = Beam_{cbf}}
\]

$\mathtt{X_{nx}}$ is defined as being horizontal at right angles to the beam, pointing to the left when 
seen from the source.  Assuming the beam is not vertical, we can compute $\mathtt{X_{nx}}$ as 
the normalized cross product of the  beam and the gravity:

\[
\mathtt{X_{nx} = (Beam_{cbf} \times Gravity_{cbf}) / || Beam_{cbf} \times Gravity_{cbf}||}
\]

To see that this satisfies the constraint of being horizontal and pointing to the left, consider the
case of $\mathtt{Beam = \left( 0, 0, -1 \right)}$ and $\mathtt{Gravity = \left( 0, 0, 1 \right)}$ then we would
have $\mathtt{X_{nx} = \left( 1, 0, 0 \right)}$ from the cross product above.  The normalization
is only necessary if the beam is not horizontal.

Finally $\mathtt{Y_{nx}}$ is computed as the cross product of the beam and $\mathtt{X_{nx}}$, completing
a orthonormal right-handed system with $\mathtt{Y_{nx}}$ pointing upwards:


\[
\mathtt{Y_{nx} = Beam_{cbf} \times X_{nx}}
\]


Then we know that in the imgCIF/CBF coordinate frame 

\[
  \mathtt{v_{nx} = x \cdot X_{nx} + y \cdot Y_{nx} + z \cdot Z_{nx}}
\]

Thus, given the imgCIF/CBF vectors for the true direction of the beam and the true direction of
gravity, we have a linear transformation from the NeXus coordinate frame to the imgCIF/CBF
coordinate frame.   The origins of the two frames agree.   The inverse linear transformation will
transform a vector in the imgCIF/CBF coordinate frame into the NeXus coordinate frame.

In the common case in which the beam is orthogonal to the principal goniometer axis so
that $\mathtt{Beam_{cbf} = \left( 0, 0, -1 \right)}$ and the imgCIF/CBF Y-axis points upwards, the transformation
inverts the X and Z axes.  In the other common case in which the beam is orthogonal to the 
principal goniometer axis and the imgCIF/CBF Y-axis points downwards, the transformation
inverts the Y and Z axes.      
                                          
  
\subsubsection{Mapping Axes}

There are two transformations needed:  $\mathtt{coordxform(v)}$ which takes a vector, $\mathtt{v}$, the
the CBF imgCIF Standard Laboratory Coordinate System and returns the equivalent
McStas coordinate vector, and $\mathtt{offsetxform(o)}$ which takes an offset, $o$, in the
the CBF imgCIF Standard Laboratory Coordinate System and returns the equivalent
NeXus offset.  As of this writing, it has not been decided as to whether the NeXus
offset should also be relative (in which case $\mathtt{offsetxform = coordxform}$) or
whether the NeXus offset should be absolute.

In imgCIF/CBF all the information about all axes other than their settings are gathered in
one AXIS category.  The closest equivalent container in NeXus is the NXinstrument class,
We put the information about detector axes into an detector:NXdetector NeXus class instance, 
information about the goniometer into an goniometer:NXsample NeXus class instance, etc.
Additionally, in view of the general nature of some axes, such as the coordinate frame
axes and gravity, we add a coordinate\_system:NXcoordinate\_system NeXus class instance with 
axis\_\_gravity, axis\_\_beam and other axes not tied to specific equipment.

We have applied the coordinate frame transformation changing
the CBF laboratory coordinates into McStas coordinates.  Notice that X and Z have changed
direction, but Y has not.   In other experimental setup, other transformations may
accur.   The offsets for dependent axes are given relative to the total
offset of axes on which that axis is dependent.  Note that the
axis settings do not enter into this calculation, because the
offsets of dependent axes are given with all axes at their
zero settings

The cbf\_location attribute gives a mapping back into the CBF AXIS category in dotted
notation.  The first component is the data block.  The second component is ``axis''.
The third component is either ``vector'' or ``offset''  for information drawn from the 
AXIS.VECTOR[...] or AXIS.OFFSET[...] respectively.  The last component is the
CBF row number to facilitate recovering the original CBF layout.


\subsection{The DIFFRN\_DATA\_FRAME category}

{\footnotesize \tt
Data items in the DIFFRN\_DATA\_FRAME category record
the details about each frame of data.\\
~~\\
The items in this category were once in a
DIFFRN\_FRAME\_DATA category, which is now deprecated.
The items from the old category are provided
as aliases but should not be used for new work.\\
~~\\
The mapping from CBF into NeXus for the DIFFRN\_DATA\_FRAME category is:

\begin{verbatim}     
    _diffrn_data_frame.array_id ARRAYID
    _diffrn_data_frame.array_section_id SECTIONID
    _diffrn_data_frame.binary_id BINID
    _diffrn_data_frame.center_fast CENF
    _diffrn_data_frame.center_slow CENS
    _diffrn_data_frame.center_units UNITS
    _diffrn_data_frame.detector_element_id ELEMENTID
    _diffrn_data_frame.id FRAMEID
    _diffrn_data_frame.details DETAILS
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    /entry:NXentry
      /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
          /CBF_diffrn_data_frame__section_id=[SECTIONIDARRAY]
          /CBF_diffrn_data_frame__binary_id=[BINARYIDARRAY]
          /CBF_diffrn_data_frame__center_fast_slow=[CENTERARRAY]
            @units="UNITS"
          /CBF_diffrn_data_frame__details=["DETAILSARRAY"]
                                 
inserts either ARRAYID (if SECTIONID is not specified or SECTIONID
into the element of SECTIONIDARRY for this frame and for this detector
element (see below);

inserts BINID into the element of BINARYIDARRAY for this frame and for this detector
element (see below);

inserts CENF into the element of CENTERARRAY for this frame, for this detector element
and for the fast centre (see below);

inserts CENS into the element of CENTERARRAY for this frame, for this detector element
and for the slow centre (see below);

only one CENTERARRY unit is provided.  If there is variation, the values in
CENTERARRAY should be rescaled to uniform units.

_diffrn_data_frame.detector_element_id ELEMENTID -->
ELEMENTID used to index into the arrays of this category by the ordinal of
the matching ELEMENTID in DIFFRN_DETECTOR_ELEMENT__id for the fast index;

FRAMEID used to index into the arrays of this category by the ordinal of
the matching ELEMENTID in DIFFRN_DETECTOR_ELEMENT__id for the slow index
by matching FRAMEID against _diffrn_scan_frame.frame_id and using
_diffrn_scan_frame.frame_number from the same row.

inserts DETAILS into the element of DETAILSARRAY for this frame and for this detector
element (see below);

The arrays created in the mapping have a slow index of the number of frames
and a fast index of the number of detector elements.  There is a middle
index for CENTERARRAY in the order fast and then slow.
\end{verbatim}
}
              


\subsection{The DIFFRN\_DETECTOR category}

{\footnotesize \tt
Data items in the DIFFRN\_DETECTOR category describe the
detector used to measure the scattered radiation, including
any analyser and post-sample collimation.\\
~~\\
The mapping from CBF into NeXus for the DIFFRN\_DETECTOR category is:
}
\begin{verbatim}     
    _diffrn_detector.diffrn_id DIFFRNID
    _diffrn_detector.id DETECTORNAME
    _diffrn_detector.details DETAILS
    _diffrn_detector.detector DETECTOR
    _diffrn_detector.dtime DTIME 
    _diffrn_detector.gain_setting GAINSETTING
    _diffrn_detector.number_of_axes NAXES
    _diffrn_detector.type DETTYPE
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
      /entry:NXentry
        /CBF_scan_id="SCANID"      
        /CBF_diffrn_id="DIFFRNID"  
          /instrument:NXinstrument 
           /DETECTORNAME:NXdetector_group
           /DETECTORELEMENTNAME:NXdetector
              /details="DETAILS"
              /type="DETECTOR"
              /deadtime=DTIME
              /number_of_axes=NAXES
              /description="DETTYPE"
              /gain_setting="GAINSETTING"
\end{verbatim}


\subsection{The DIFFRN\_DETECTOR\_AXIS category}

{\footnotesize \tt
Data items in the DIFFRN\_DETECTOR\_AXIS category associate
axes with detectors.\\
}
~~\\
The mapping from CBF into NeXus for the DIFFRN\_DETECTOR\_AXIS category is:

\begin{verbatim}     
    _diffrn_detector_axis.axis_id AXISID -->
    _diffrn_detector_axis.detector_id DETECTORNAME -->
        /instrument:NXinstrument
         /DETECTORNAME:NXdetector_group
         /DETECTORELEMENTNAME:NXdetector
            /transformations:NXtransformations
              /AXISID=[]
    
This information normally will duplicate information obtained from
the ARRAY_STRUCTURE_LIST_AXIS.
\end{verbatim}  


\subsubsection{DIFFRN\_DETECTOR\_ELEMENT category}

\footnotesize \tt
Data items in the DIFFRN\_DETECTOR\_ELEMENT category record
the details about spatial layout and other characteristics
of each element of a detector which may have multiple elements.\\
~~\\
In most cases, giving more detailed information
in ARRAY\_STRUCTURE\_LIST and ARRAY\_STRUCTURE\_LIST\_AXIS
is preferable to simply providing the centre of the
 detector element.


\subsection{The DIFFRN\_MEASUREMENT category}

{\footnotesize \tt
Data items in the DIFFRN\_MEASUREMENT category record details
about the device used to orient and/or position the crystal
during data measurement and the manner in which the
diffraction data were measured.\\
~~\\
The mapping from CBF into NeXus for the DIFFRN\_MEASUREMENT category is:

\begin{verbatim}     
    _diffrn_measurement.diffrn_id DIFFRNID
    _diffrn_measurement.details DETAILS
    _diffrn_measurement.device DEVICE
    _diffrn_measurement.device_details DEVDETAILS
    _diffrn_measurement.device_type DEVTYPE
    _diffrn_measurement.id GONIOMETER
    _diffrn_measurement.method METHOD
    _diffrn_measurement.number_of_axes NUMBER
    _diffrn_measurement.sample_detector_distance DIST
    _diffrn_measurement.sample_detector_distance_derived DISTDERIVED
    _diffrn_measurement.sample_detector_voffset VOFST
    _diffrn_measurement.specimen_support SPECSPRT
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    /entry:NXentry
      /CBF_scan_id="SCANID
      /CBF_diffrn_id="DIFFRNID"
      /instrument:NXinstrument
      /CBF_diffrn_measurement__GONIOMETER:NXgoniometer
        /details="DETAILS"
        /local_name="DEVICE"       
        /description="DEVDETAILS"  
        /type="DEVTYPE"            
        /CBF_diffrn_measurement__method="METHOD"
          /number_of_axes=NUMBER
        /CBF_diffrn_measurement__specimen_support="SPECSPRT"
      /CBF_diffrn_detector__DETECTORNAME:NXdetector
        /distance=DIST
          @units="mm"
        /distance_derived=DISTDERIVED
        /CBF_diffrn_measurement__sample_detector_voffset=VOFST
          @units="mm"
\end{verbatim}


\subsection{The DIFFRN\_MEASUREMENT\_AXIS category}

{\footnotesize \tt
Data items in the DIFFRN\_MEASUREMENT\_AXIS category associate axes with goniometers.\\
~~\\
The mapping from CBF into NeXus for the DIFFRN\_MEASUREMENT\_AXIS category is:

\begin{verbatim}     
    _diffrn_measurement_axis.axis_id AXISID
    _diffrn_measurement_axis.measurement_device DEVICE
    _diffrn_measurement_axis.measurement_id GONIOMETER
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    /entry:NXentry
      /CBF_scan_id="SCANID
      /CBF_diffrn_id="DIFFRNID"
      /sample:NXsample
        /transformations:NXtransformations
          /AXISID=[]      
      /instrument:NXinstrument
        /CBF_diffrn_measurement__GONIOMETER:NXgoniometer
          /CBF_diffrn_measurement__device="DEVICE"
\end{verbatim}
}
       


\subsection{The DIFFRN\_RADIATION category}

{\footnotesize \tt
Data items in the DIFFRN\_RADIATION category describe
the radiation used for measuring diffraction intensities,
its collimation and monochromatization before the sample.\\
~~\\
Post-sample treatment of the beam is described by data
items in the DIFFRN\_DETECTOR category.\\
~~\\
The mapping from CBF into NeXus for the DIFFRN\_RADIATION category is:

\begin{verbatim}     
    _diffrn_radiation.collimation    COLLIMATION
    _diffrn_radiation.diffrn_id      DIFFRNID
    _diffrn_radiation.div_x_source   DIVX
    _diffrn_radiation.div_y_source   DIVY
    _diffrn_radiation.div_x_y_source DIVXY
    _diffrn_radiation.filter_edge'   ABSEDGE
    _diffrn_radiation.inhomogeneity  HWIDTH
    _diffrn_radiation.monochromator  MONOCHROMATOR
    _diffrn_radiation.polarisn_norm  POLNANG
    _diffrn_radiation.polarisn_ratio POLRAT
    _diffrn_radiation.polarizn_source_norm   POLSNANG
    _diffrn_radiation.polarizn_source_ratio  POLSRAT
    _diffrn_radiation.polarizn_Stokes_I  SVECI
    _diffrn_radiation.polarizn_Stokes_Q  SVECQ
    _diffrn_radiation.polarizn_Stokes_U  SVECU
    _diffrn_radiation.polarizn_Stokes_V  SVECV
    _diffrn_radiation.polarisn_norm_esd  POLNANGESD
    _diffrn_radiation.polarisn_ratio_esd POLRATESD
    _diffrn_radiation.polarizn_source_norm_esd   POLSNANGESD
    _diffrn_radiation.polarizn_source_ratio_esd  POLSRATESD
    _diffrn_radiation.polarizn_Stokes_I_esd  SVECIESD
    _diffrn_radiation.polarizn_Stokes_Q_esd  SVECQESD
    _diffrn_radiation.polarizn_Stokes_U_esd  SVECUESD
    _diffrn_radiation.polarizn_Stokes_V_esd  SVECVESD
    _diffrn_radiation.probe          RADIATION
    _diffrn_radiation.type           SIEGBAHNTYPE
    _diffrn_radiation.xray_symbol    IUPACXRAYSYMB
    _diffrn_radiation.wavelength_id  ID
    _diffrn_radiation_wavelength.id  ID
    _diffrn_radiation_wavelength.wavelength    WAVELENGTH
    _diffrn_radiation_wavelength.wt            WEIGHT
    _diffrn_scan_frame.polarizn_Stokes_I STOKESI
    _diffrn_scan_frame.polarizn_Stokes_Q STOKESQ
    _diffrn_scan_frame.polarizn_Stokes_U STOKESU
    _diffrn_scan_frame.polarizn_Stokes_V STOKESV
    _diffrn_scan_frame.polarizn_Stokes_I_esd STOKESIESD
    _diffrn_scan_frame.polarizn_Stokes_Q_esd STOKESQESD
    _diffrn_scan_frame.polarizn_Stokes_U_esd STOKESUESD
    _diffrn_scan_frame.polarizn_Stokes_V_esd STOKESVESD
    _diffrn_scan_frame.frame_number FRAMENO
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
       /entry:NXentry
         /CBF_scan_id="SCANID"
         /sample:NXsample
           /beam:NXbeam
             /incident_divergence_x=DIVX
               @units="degrees"
             /incident_divergence_y=DIVY
               @units="degrees"
             /incident_divergence_xy=DIXXY
               @units="degrees^2"
             /CBF_diffrn_radiation_wavelength__wavelength_id=[WAVELENGTH_ID]
             /incident_wavelength=[WAVELENGTH]
               @units="A"
             /weight=[WEIGHT]
             /incident_polarisation_stokes_average=[SVECI,SVECQ,SVECU,SVECV]
             /incident_polarisation_stokes_average_uncertainty=[SVECIESD,SVECQESD,SVECUESD,SVECVESD]
             /incident_polarisation_stokes=[STOKESI,STOKESQ,STOKESU,STOKESV]
             /incident_polarisation_stokes_uncertainty=[STOKESIESD,STOKESQESD,STOKESUESD,STOKESVESD]
               @units="Watts/meter^2"
             /CBF_diffrn_radiation__polarisn_norm=POLNANG
               @units="deg"
             /CBF_diffrn_radiation__polarisn_ratio=POLRAT
             /CBF_diffrn_radiation__polarisn_norm_uncertainty=POLNANGESD
               @units="deg"
             /CBF_diffrn_radiation__polarisn_ratio_uncertainty=POLRATESD
             /CBF_diffrn_radiation__polarisn_source_norm=POLSNANG
               @units="deg"
             /CBF_diffrn_radiation__polarizn_source_ratio=POLSRAT
             /CBF_diffrn_radiation__polarisn_source_norm_uncertainty=POLSNANGESD
               @units="deg"
             /CBF_diffrn_radiation__polarizn_source_ratio_uncertainty=POLSRATESD
             /CBF_diffrn_radiation__filter_edge=ABSEDGE
                @units="angstroms"
             /CBF_diffrn_radiation__inhomogeneity=HWIDTH
                @units="mm"
         /instrument:NXinstrument
           /monochromator:NXmonochromator
             /description="MONOCHROMATOR"
           /source:NXsource
             /probe="RADIATION"
             /CBF_diffrn_radiation__type="SIEGBAHNTYPE"
             /CBF_diffrn_radiation__xray_symbol="IUPACXRAYSYMB"

         With the incident_polarisation_stokes array indexed by FRAMENO

\end{itemize}
}

\subsection{The DIFFRN\_RADIATION\_WAVELENGTH category}

\footnotesize{\begin{verbatim}
The DIFFRN_RADIATION_WAVELENGTH category is defined in
the Protein Data Bank's PDBx/mmmCIF dictionary
\cite{westbrook2022pdbx}
    
Data items in the DIFFRN_RADIATION_WAVELENGTH category
describe the wavelength of the radiation used to measure the
diffraction intensities. Items may be looped to identify
and assign weights to distinct components of a
polychromatic beam.

\end{verbatim}}


\begin{itemize}

\item{\_diffrn\_radiation\_wavelength.id ID$\rightarrow$ \\
/instrument:NXinstrument \\
\verb|  |/CBF\_diffrn\_radiation\_wavelength\_\_id=["ID"]
}
\item{\_diffrn\_radiation\_wavelength.wavelength\_id WAVELENGTH\_ID$\rightarrow$ \\
/instrument:NXinstrument \\
\verb|  |/CBF\_diffrn\_radiation\_wavelength\_\_wavelength\_id=["WAVELENGTH\_ID"] \\
}
\item{\_diffrn\_radiation\_wavelength.wavelength WAVELENGTH $\rightarrow$ \\
/instrument:NXinstrument \\
\verb|  |/CBF\_diffrn\_radiation\_wavelength\_\_wavelength=[WAVELENGTH] \\
}
\item{\_diffrn\_radiation\_wavelength.wt WEIGHT$\rightarrow$
/instrument:NXinstrument \\
\verb|  |/CBF\_diffrn\_radiation\_wavelength\_\_wt=[WEIGHT] \\
}

\item{\_diffrn\_radiation\_wavelength.variant $\rightarrow$ ?? ({\it NeXus does not handle variants at this time})}
\end{itemize}

\subsection{The DIFFRN\_REFLN category}

\footnotesize{\begin{verbatim}
This category redefinition has been added to extend the key of
the standard DIFFRN_REFLN category from mmCIF.

Data items in the DIFFRN_REFLN category record details about
the intensities in the diffraction data set
identified by _diffrn_refln.diffrn_id.

The DIFFRN_REFLN data items refer to individual intensity
measurements and must be included in looped lists.

The DIFFRN_REFLNS data items specify the parameters that apply
to all intensity  measurements in the particular diffraction
data set identified by _diffrn_reflns.diffrn_id and
_diffrn_refln.frame_id
    
There are proposals on handling reflections in NeXus in
NXreflections.  When the discusssions are resolved this
section will be updated.
   
\begin{itemize}

\item{\_diffrn\_refln.frame\_id $\rightarrow$ ??}

\item{\_diffrn\_refln.variant $\rightarrow$ ??}
\end{itemize}
}


\subsection{The DIFFRN\_SCAN category}

\footnotesize{\begin{verbatim}
Data items in the DIFFRN_SCAN category describe the parameters of one
or more scans, relating axis positions to frames.
\end{verbatim}

The mapping from CBF into NeXus for the DIFFRN\_SCAN category is:

\begin{verbatim}     
    _diffrn_scan.id SCANID
    _diffrn_scan.date_end ENDDATETIME
    _diffrn_scan.date_end_estimated ENDDATETIMEEST
    _diffrn_scan.date_start STARTDATETIME
    _diffrn_scan.integration_time AVGCOUNTTIME
    _diffrn_scan.frame_id_start FRAMESTARTID
    _diffrn_scan.frame_id_end FRAMEENDID
    _diffrn_scan.frames FRAMES
    _diffrn_scan.time_period TIMEPER
    _diffrn_scan.time_rstrt_incr RSTRTTIME
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
        /entry:NXentry
          /CBF_scan_id="SCANID"
          /end_time=ENDDATETIME
          /end_time_estimated=ENDDATETIMEEST
          /start_time=STARTDATETIME
          /average_count_time=AVGCOUNTTIME
            @units="sec"
          /average_frame_time=TIMEPER
            @units="sec"
          /average_frame_restart_time=RSTRTTIME
            @units="sec"
          /instrument:NXinstrument
           /DETECTORNAME:NXdetector_group
           /DETECTORELEMENTNAME:NXdetector
              /frame_start_number=FRAMESTARTNO
              /frame_end_number=FRAMEENDNO

    FRAMESTARTNO is the value of _diffrn_scan_frame.frame_number
    for which the value of _diffrn_scan_frame.frame_id equals FRAMESTARTID
    FRAMEENDNO is the value of _diffrn_scan_frame.frame_number
    for which the value of _diffrn_scan_frame.frame_id equals FRAMEENDID   
\end{itemize}
}


\subsection{The DIFFRN\_SCAN\_AXIS category}

\footnotesize{\begin{verbatim}
Data items in the DIFFRN_SCAN_AXIS category describe the settings of
axes for particular scans.  Unspecified axes are assumed to be at
their zero points.
\end{verbatim}

The mapping from CBF into NeXus for the DIFFRN\_SCAN\_AXIS category is:

\begin{verbatim}     
    _diffrn_scan_axis.axis_id AXISID-->
    _diffrn_scan_axis.angle_start ANGSTART
    _diffrn_scan_axis.angle_range ANGRANGE 
    _diffrn_scan_axis.angle_increment ANGINC 
    _diffrn_scan_axis.angle_rstrt_incr ANGRSTRT 
    _diffrn_scan_axis.displacement_start DISPSTART 
    _diffrn_scan_axis.displacement_range DISPRANGE 
    _diffrn_scan_axis.displacement_increment DISPINC 
    _diffrn_scan_axis.displacement_increment DISPINC 
    _diffrn_scan_axis.displacement_rstrt_incr DISPRSTRT 
    _diffrn_scan_axis.reference_angle ANG 
    _diffrn_scan_axis.reference_displacement DISP 
    _diffrn_scan_axis.scan_id SCANID
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    { /entry:NXentry
      /CBF_scan_id="SCANID"
      /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
    for AXISEQUIPMENT=="detector"}
    {  /CBF_diffrn_scan__SCANID:NXentry
         /sample:NXsample
    for AXISEQUIPMENT=="goniometer"}
    {  /CBF_diffrn_scan__SCANID:NXentry
    for AXISEQUIPMENT=="general"}
         /transformations:NXtransformations
           /AXISID=[]
             @diffrn_scan_axis__angle_start=ANGSTART
             @diffrn_scan_axis__angle_range=ANGRANGE
             @diffrn_scan_axis__angle_increment=ANGINC
             @diffrn_scan_axis__angle_rstrt_incr=ANGRSTRT
             @diffrn_scan_axis__displacement_start=DISPSTART
             @diffrn_scan_axis__displacement_range=DISPRANGE
             @diffrn_scan_axis__displacement_increment=DISPINC
             @diffrn_scan_axis__displacement_rstrt_incr=DISPRSTRT
             @diffrn_scan_axis__reference_angle=ANG
             @diffrn_scan_axis__reference_displacement=DISP
\end{itemize}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \subsection{The DIFFRN\_SCAN\_FRAME category}

\footnotesize{\begin{verbatim}
Data items in the DIFFRN_SCAN_FRAME category describe
the relationships of particular frames to scans.
\end{verbatim}

The mapping from CBF into NeXus for the DIFFRN\_SCAN\_FRAME category is:

\begin{verbatim}     
    _diffrn_scan_frame.date  DATETIME
    _diffrn_scan_frame.frame_id ID
    _diffrn_scan_frame.frame_number FRAMENUMBER
    _diffrn_scan_frame.integration_time COUNTTIME
    _diffrn_scan_frame.polarizn_Stokes_I STOKESI
    _diffrn_scan_frame.polarizn_Stokes_Q STOKESQ
    _diffrn_scan_frame.polarizn_Stokes_U STOKESU
    _diffrn_scan_frame.polarizn_Stokes_V STOKESV
    _diffrn_scan_frame.scan_id SCANID
    _diffrn_scan_frame.time_period FRAMETIME
    _diffrn_scan_frame.time_rstrt_incr RSTRTTIME
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    /entry:NXentry
      /CBF_scan_id="SCANID"
      /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
          /CBF_diffrn_scan_frame__date=["DATETIME"]
          /CBF_diffrn_scan_frame__frame_id=["ID"]
          /count_time=[COUNTIME]
          /frame_time=[FRAMETIME]
          /frame_restart_time=[RSTRTTIME]
      /sample:NXsample
        /beam:NXbeam
          /incident_polarisation_stokes=[STOKESI,STOKESQ,STOKESU,STOKESV]
             @units="Watts/meter^2"
     where each array element is inserted at index FRAMENUMBER          
\end{itemize}
}


\subsection{The DIFFRN\_SCAN\_FRAME\_AXIS category}

\footnotesize{\begin{verbatim}
Data items in the DIFFRN_SCAN_FRAME_AXIS category describe the
settings of axes for particular frames.  Unspecified axes are
assumed to be at their zero points.  If, for any given frame,
nonzero values apply for any of the data items in this category,
those values should be given explicitly in this category and not
simply inferred from values in DIFFRN_SCAN_AXIS.
\end{verbatim}

The mapping from CBF into NeXus for the DIFFRN\_SCAN\_FRAME\_AXIS category is:

\begin{verbatim}     
    _diffrn_scan_frame_axis.axis_id AXISID
    _diffrn_scan_frame_axis.angle ANGLE
    _diffrn_scan_frame_axis.angle_increment ANGLEINCREMENT
    _diffrn_scan_frame_axis.angle_rstrt_incr ANGLERSTRTINCREMENT
    _diffrn_scan_frame_axis.displacement DISP 
    _diffrn_scan_frame_axis.displacement_increment DISPINCREMENT
    _diffrn_scan_frame_axis.displacement_rstrt_incr DISPRSTRTINCREMENT
    _diffrn_scan_frame_axis.reference_angle REFANGLE
    _diffrn_scan_frame_axis.reference_displacement REFDISP
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    { /entry:NXentry
      /CBF_scan_id="SCANID"
      /instrument:NXinstrument
       /DETECTORNAME:NXdetector_group
       /DETECTORELEMENTNAME:NXdetector
    for AXISEQUIPMENT=="detector"}
    {  /entry:NXentry
         /sample:NXsample
    for AXISEQUIPMENT=="goniometer"}
    {  /entry:NXentry
    for AXISEQUIPMENT=="general"}
         /transformations:NXtransformations
           /AXISID=[]
             @diffrn_scan_frame_axis__angle_start=[ANGSTART]
             @diffrn_scan_frame_axis__angle_range=[ANGRANGE]
             @diffrn_scan_frame_axis__angle_increment=[ANGINC]
             @diffrn_scan_frame_axis__angle_rstrt_incr=[ANGRSTRT]
             @diffrn_scan_frame_axis__displacement_start=[DISPSTART]
             @diffrn_scan_frame_axis__displacement_range=[DISPRANGE]
             @diffrn_scan_frame_axis__displacement_increment=[DISPINC]
             @diffrn_scan_frame_axis__displacement_rstrt_incr=[DISPRSTRT]
             @diffrn_scan_frame_axis__reference_angle=[ANG]
             @diffrn_scan_frame_axis__reference_displacement=[DISP]


note that @units="mm" or @units="deg" should also be specified.

The dimensions of the array depend on np (the number of frames = the
value of _diffrn_scan.frames)

either DISP OR ANGLE is inserted as the i-th element
counting from 1 in AXISID where i is the value of
_diffrn_scan_frame.frame_number for which the value
of _diffrn_scan_frame.frame_id agrees with the
value of _diffrn_scan_frame_axis.frame_id

The remaining tags similarly populate the attribute arrays
\end{itemize}
}


\subsection{The DIFFRN\_SCAN\_FRAME\_MONITOR category}

\footnotesize{\begin{verbatim}
Data items in the DIFFRN_SCAN_FRAME_MONITOR category record
the values and details about each monitor for each frame of data
during a scan.

Each monitor value is uniquely identified by the combination of
the scan id given by _diffrn_scan_frame.scan_id,
the frame id given by _diffrn_scan_frame_monitor.frame_id,
the monitor's detector id given by 
_diffrn_scan_frame_monitor.detector_id,
and a 1-based ordinal given by _diffrn_scan_frame_monitor.id.

If there is only one frame for the scan, the value of
_diffrn_scan_frame_monitor.frame_id may be omitted.

A single frame may have more than one monitor value, and each 
monitor value may be the result of integration over the entire
frame integration time given by the value of
_diffrn_scan_frame.integration_time,
or many monitor values may be reported over shorter times given 
by the value of _diffrn_scan_frame_monitor.integration_time.  If 
only one monitor value for a given monitor is collected during 
the integration time of the frame, the value of
_diffrn_scan_frame_monitor.id may be
omitted.
\end{verbatim}

The mapping from CBF into NeXus for the DIFFRN\_SCAN\_FRAME\_MONITOT category is:

\begin{verbatim}     
    _diffrn_scan_frame_monitor.id MONID -->
    _diffrn_scan_frame_monitor.detector_id DETECTORNAME -->
    _diffrn_scan_frame_monitor.scan_id SCANID -->
    _diffrn_scan_frame_monitor.frame_id FRAMEID -->
    _diffrn_scan_frame_monitor.integration_time INTEGRATIONTIME -->
    _diffrn_scan_frame_monitor.monitor_value MONITORVALUE -->
\end{verbatim}
~~~~~~{\bf{}$\rightarrow$}\\
\begin{verbatim}
    /entry:NXentry
      /CBF_scan_id="SCANID"
        /instrument:NXinstrument
          /CBF_diffrn_scan_frame_monitor__DETECTORNAME_MONID:NXmonitor
            @CBF_detector_id="DETECTORNAME"
            @CBF_diffrn_scan_frame_monitor__id="MONID"
            /data=[MONITORVALUE]  
            /count_time=[INTEGRATIONTIME] 
\end{itemize}
}

\subsection{The MAP category}

{\footnotesize\begin{verbatim}
Data items in the MAP category record
the details of a maps. Maps record values of parameters,
such as density, that are functions of position within
a cell or are functions of orthogonal coordinates in
three space.
  
A map may is composed of one or more map segments
specified in the MAP\_SEGMENT category.
\end{verbatim}}

\begin{itemize}

\item{\_map.details $\rightarrow$ ??}

\item{\_map.diffrn\_id $\rightarrow$ ??}

\item{\_map.entry\_id $\rightarrow$ ??}

\item{\_map.id $\rightarrow$ ??}

\item{\_map.variant category $\rightarrow$ ??}
\end{itemize}

To be mapped to NeXus in the future.

\subsubsection{The MAP\_SEGMENT category}

{\footnotesize\begin{verbatim}
Data items in the MAP_SEGMENT category record
the details about each segment (section or brick) of a map.
\end{verbatim}}

\begin{itemize}

\item{\_map\_segment.array\_id $\rightarrow$ ??}

\item{\_map\_segment.array\_section\_id $\rightarrow$ ??}

\item{\_map\_segment.binary\_id $\rightarrow$ ??}

\item{\_map\_segment.mask\_array\_id $\rightarrow$ ??}

\item{\_map\_segment.mask\_array\_section\_id $\rightarrow$ ??}

\item{\_map\_segment.mask\_binary\_id $\rightarrow$ ??}

\item{\_map\_segment.id $\rightarrow$ ??}

\item{\_map\_segment.map\_id $\rightarrow$ ??}

\item{\_map\_segment.details $\rightarrow$ ??}

\item{\_map\_segment.variant category $\rightarrow$ ??}
\end{itemize}

To be mapped to NeXus in the future.

\subsection{The VARIANT category}

{\footnotesize\begin{verbatim}
Data items in the VARIANT category record
the details about sets of VARIANTs of data items.

There is sometimes a need to allow for multiple versions of the
same data items in order to allow for refinements and corrections
to earlier assumptions, observations and calculations.  In order
to allow data sets to contain more than one VARIANT of the same
information, an optional ...variant data item as a pointer to
_variant.variant has been added to the key of every category,
as an implicit data item with a null (empty) default value.

All rows in a category with the same VARIANT value are considered 
to be related to one another and to all rows in other categories
with the same VARIANT value.  For a given VARIANT, all such rows
are also considered to be related to all rows with a null VARIANT
value, except that a row with a null VARIANT value is for which
all other components of its key are identical to those entries
in another row with a non-null VARIANT value is not related the
the rows with that non-null VARIANT value.  This behavior is 
similar to the convention for identifying alternate conformers 
in an atom list.

An optional role may be specified for a VARIANT as the value of
_variant.role.  Possible roles are null, "preferred", 
"raw data", "unsuccessful trial".

    VARIANTs may carry an optional timestamp as the value of
    _variant.timestamp.
    
    VARIANTs may be related to other VARIANTs from which they were
    derived by the value of _variant.variant_of
    
    Further details about the VARIANT may be specified as the value
    of _variant.details.
    
    In order to allow VARIANT information from multiple datasets to
    be combined, _variant.diffrn_id and/or _variant.entry_id may
    be used. 
\end{verbatim}}

\begin{itemize}

\item{\_variant.details $\rightarrow$ ??}

\item{\_variant.role $\rightarrow$ ??}

\item{\_variant.timestamp $\rightarrow$ ??}

\item{\_variant.variant $\rightarrow$ ??}

\item{\_variant.variant\_of $\rightarrow$ ??}
\end{itemize}

To be mapped to NeXus in the future.


\section{Mapping from NeXus to CBF/imgCIF}
\label{Mapping from NeXus to CBF/imgCIF}

Mapping from NeXus to CBF/imgCIF is matter of establishing appropriate
tables and columns for each of the NeXus classes.  In general, a NeXus
class will correspond to a category, while the specific name will
be part of the key of that category, usually the id of the category.
The terms in NeXus may be defined in base classes (see
\url{http://download.nexusformat.org/doc/html/classes/base_classes/index.html})
or in application definitions (see
\url{http://download.nexusformat.org/doc/html/classes/applications/index.html}).
We will consider them one at a time.

As with the mapping from CBF to NeXus, where we do both a complete faithful
mapping of a CBF to a NeXus tree in CBF\_cbf, and a more structured tag-by-tag
mapping throughout the NeXus tree, in his direction we will address a complete
faithful mapping of all features of a NeXus tree into a single CBF data block
as well as a more structured item-by-item mapping.

\subsection{Faithful Mapping of a NeXus Tree}

A NeXus tree is a tree of HDF5 groups, each with an associated NeXus class.
For the full faithful mapping in to a single CBF datablock, which will
be given the name NeXus\_Tree, each NeXus class will be mapped to a
CBF category of the same name, and each instance of that class will
be mapped to a single row in that table.  The unique identifier of
a row, in the column NX\_tree\_path will be the rooted path to the 
particular NeXus class instance in the tree.  Each path component
will consist of the NeXus class composed with the actual name of the NeXus class instance in
dotted notation, with an underscore before each NeXus class name.
Each subgroup of a NeXus class instance (also a NeXus class instance) will be entered into a column 
named with name of the subgroup, with a value equal to the rooted
path to that subgroup.

For example, in the NeXus tree

\begin{verbatim}
\entry:NXentry
  \instrument:NXinstrument
    \detector:NXdetector
\end{verbatim}

the mapping would be to

\begin{verbatim}
_datablock_NeXus_Tree

loop_
_NXentry.NX_tree_path  "/_NXentry.entry"
_NXentry.instrument   
"/_NXentry.entry"   "/_NXentry.entry/_NXinstrument.instrument"

loop_
_NXinstrument.NX_tree_path 
_NXinstrument.detector   
"/_NXentry.entry/_NXinstrument.instrument" "/_NXentry.entry/_NXinstrument.instrument/_NXdetector__detector"

_NXdetector.detector "/_NXentry.entry/_NXinstrument.instrument/_NXdetector__detector"
\end{verbatim}

An attribute of a NeXus class other than the HDF5 attribute for the NeXus class name itself
will be given a 
column name composed from the prefix ``NX\_class\_attribute\_\_" and the name of the attribute.


\subsection{Mapping Fields}
\label{Mapping Fields}

Fields share some of the characteristics of classes and some if the
characteristics of attributes.  When a rooted path to a field is needed
in this discussion, the rooted path be composed of the NeXus class 
composed with the name of the NeXus class instance composed with the name of
the field in dotted notation, with an underscore before each NeXus class name.

If a NeXus class instance is given in the NeXus tree by a link, rather than directly an extra tag
having the name of the column with the suffix "\_\_link" will be used to carry
the link path to the target in addition to giving the path to the origin of the link.

The mapping of fields in NeXus class instances will be handled in one
of two ways:
\begin{itemize}

\item{If instances of a NeXus class are each permitted to contain multiple
instances of a field, each field instance will be handled like a
NeXus class instance, with the modification to rooted paths noted above.
Each such field will be assigned a column name that is generic to the instances,
such as ``data'' or ``axis\_poise'', and a category name beginning with ``NX\_'' will
be generated to hold the field instance value and attribute values.  The
value in the column will be a list of the rooted paths to the field instances.}

\item{if each instance of a NeXus class may only contain one unique
instance of a field, then the field name will be used as the column name.
The value of the column for a field will be the verbatim
value of the field, using the CBF binary data type when needed, or CIF 2 lists and tuples
when needed.  Attributes of fields are handled by creating a column beginning with the name of
the column of the field and appending the attribute name in dotted notation,
converting the dots to double underscores.}

\end{itemize}


For example, in the NeXus tree

\begin{verbatim}
\entry:NXentry
  \instrument:NXinstrument
    \detector:NXdetector
       \data=BINDATA
         \@signal=1
\end{verbatim}

the mapping would be to 

\begin{verbatim}
_datablock_NeXus_Tree


_loop_
_NXentry.NX_tree_path  "/_NXentry.entry"
_NXentry.instrument   
"/_NXentry.entry"   "/_NXentry.entry/_NXinstrument.instrument"

loop_
_NXinstrument.NX_tree_path 
_NXinstrument.detector   
"/_NXentry.entry/_NXinstrument.instrument" "/_NXentry.entry/_NXinstrument.instrument/_NXdetector__detector"

loop_
_NXdetector.NX_tree_path 
_NXdetector.data      BINDATA
_NXdetector.data__signal  

"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__detector"  BINDATA  1

\end{verbatim}

While, in the NeXus tree

\begin{verbatim}
    /entry:NXentry
       /instrument:NXinstrument
          /CBF\_diffrn_detector__detector:NXdetector
             CBF_axis__DETECTOR_PITCH=[0.]
                @units="deg"
                @cbf_location="image_1.axis.vector.10"
                @depends_on="CBF_axis__DETECTOR_Y"
                @transformation_type="rotation"
                @vector=[-1, 0, 0]
             CBF_axis__DETECTOR_Y=[0.]
                @units="mm"
                @cbf_location="image_1.axis.vector.9"
                @depends_on="CBF_axis__DETECTOR_Z"
                @transformation_type="translation"
                @vector=[0, -1, 0]
             CBF_axis__DETECTOR_Z=[250.]
                @units="mm"
                @cbf_location="image_1.axis.vector.8"
                depends_on="."
                @transformation_type="translation"
                @vector= [0, 0, 1]
             CBF_axis__ELEMENT_X=[0.]
                @units="mm"
                @offset_units="mm"
                @cbf_location="image_1.axis.vector.11"
                @depends_on="CBF_axis__DETECTOR_PITCH"
                @transformation_type="translation"
                @vector= [-1, 0, 0]
                @offset= [-211.818, -217.322, 0]
             CBF_axis__ELEMENT_Y=[0.]
                @units="mm"
                @cbf_location=image_1.axis.vector.12
                @depends_on="CBF_axis__ELEMENT_X"
                @transformation_type="translation"
                @vector= [0, 1, 0]
\end{verbatim}

the mapping would be to 

\begin{verbatim}
_datablock_NeXus_Tree


_loop_
_NXentry.NX_tree_path  "/_NXentry.entry"
_NXentry.instrument   
"/_NXentry.entry"   "/_NXentry.entry/_NXinstrument.instrument"

loop_
_NXinstrument.NX_tree_path 
_NXinstrument.detector   
"/_NXentry.entry/_NXinstrument.instrument" "/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector"

loop_
_NXdetector.NX_tree_path 
_NXdetector.axis_poise  

"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise"  
["CBF_axis__DETECTOR_PITCH","CBF_axis__DETECTOR_Y","CBF_axis__DETECTOR_Z","CBF_axis__ELEMENT_X","CBF_axis__ELEMENT_Y"]

loop_
_NX_axis_poise.NX_tree_path
_NX_axis_poise.value
_NX_axis_poise.units
_NX_axis_poise.offset_units
_NX_axis_poise.cbf_location
_NX_axis_poise.depends_on
_NX_axis_poise.transformation_type
_NX_axis_poise.vector
_NX_axis_poise.offset
\end{verbatim}

{\scriptsize \begin{verbatim}
"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise__axis__DETECTOR_PITCH"
    0. "deg"    .    "image_1.axis.vector.10"     "axis__DETECTOR_Y"    "rotation" [-1,0,0]                      .
"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise__axis__DETECTOR_Y"
    0.  "mm"    .    "image_1.axis.vector.9"      "axis__DETECTOR_Z" "translation" [0,-1,0]                      .
"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise__axis__DETECTOR_Z"
  250.  "mm"    .    "image_1.axis.vector.8"                      .  "translation" [0,0,1]                       .
"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise__axis__ELEMENT_X"
    0.  "mm"    "mm" "image_1.axis.vector.11" "axis__DETECTOR_PITCH" "translation" [-1,0,0]  [-211.818,-217.322,0]
"/_NXentry.entry/_NXinstrument.instrument/_NXdetector__diffrn_detector__detector__axis_poise__axis__ELEMENT_Y"
    0.  "mm"    .    "image_1.axis.vector.12"      "axis__ELEMENT_X" "translation" [0,1,0]                       .

\end{verbatim}}

While the full faithful mapping of the NeXus tree into CBF is primarily for development and debugging,
portions of it will also become essentially the final detailed mapping.  Notice, for example,
that the NX\_axis\_poise category in the faithful mapping has all the information needed to
populate the standard CBF axis category will minimal transformations.  In the final
detailed mapping, in addition to the NX\_tree\_path, each category will have a ``NX\_id'' column
to provide a unique identifier when a CBF originates the data and no path is available
to use as the key.  Normally this will be the last component of the path.

\section{NeXus Base Class Mapping}

The details of the NeXus base classes are provided at

\url{http://download.nexusformat.org/doc/html/classes/base_classes/index.html}

which should be consulted for getails.

\subsection{NXaperture}

Template of a beamline aperture.

\begin{verbatim}
NXaperture (base class, version 1.0)
  description:NX_CHAR
  material:NX_CHAR
  NXgeometry
  NXgeometry
  NXnote
\end{verbatim}

\begin{itemize}

\item{APERTURE:NXaperture $\rightarrow$\\
\verb|  |\_NXaperture.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXaperture.NX\_id            APERTURE\\
\verb|  |\_NXaperture.NX\_scan\_id      SCANID \\
\verb|  |\_NXaperture.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXaperture.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXaperture\_\_APERTURE''
where APERTURE is the name of this group, typically ``aperture''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXaperture.description DESCRIPTION}

\item{\verb|  |material:NX\_CHAR=MATERIAL $\rightarrow$\\
\verb|  |\_NXaperture.material MATERIAL}

\item{geometry\_aperture:NXgeometry $\rightarrow$\\
\verb|  |\_NXaperture.NXgeometry\_id geometry\_aperture}

\item{geometry\_blades:NXgeometry $\rightarrow$\\
\verb|  |\_NXaperture.NXgeometry\_id geometry\_blades}

\item{note:NXnote $\rightarrow$\\
\verb|  |\_NXaperture.NXnote\_id note}
\end{itemize}
\subsection{NXattenuator}

Description of a device that reduces the intensity of a beam by attenuation. If uncertain whether to use NXfilter (band-pass filter) or NXattenuator (reduces beam intensity), then choose NXattenuator.


\begin{verbatim}
NXattenuator (base class, version 1.0)
  absorption_cross_section:NX_FLOAT
  attenuator_transmission:NX_FLOAT
  distance:NX_FLOAT
  scattering_cross_section:NX_FLOAT
  status:NX_CHAR
    @time
  thickness:NX_FLOAT
  type:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{ATTENUATOR:NXattenuator $\rightarrow$\\
\verb|  |\_NXattenuator.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXattenuator.NX\_id            ATTENUATOR\\
\verb|  |\_NXattenuator.NX\_scan\_id      SCANID \\
\verb|  |\_NXattenuator.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXattenuator.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXattenuator\_\_ATTENUATOR''
where ATTENUATOR is the name of this group, typically ``attenuator''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |absorption\_cross\_section:NX\_FLOAT=ABSORPTION\_CROSS\_SECTION $\rightarrow$\\
\verb|  |\_NXattenuator.absorption\_cross\_section ABSORPTION\_CROSS\_SECTION}

\item{\verb|  |attenuator\_transmission:NX\_FLOAT=ATTENUATOR\_TRANSMISSION $\rightarrow$\\
\verb|  |\_NXattenuator.attenuator\_transmission ATTENUATOR\_TRANSMISSION}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXattenuator.distance DISTANCE}

\item{\verb|  |scattering\_cross\_section:NX\_FLOAT=SCATTERING\_CROSS\_SECTION $\rightarrow$\\
\verb|  |\_NXattenuator.scattering\_cross\_section SCATTERING\_CROSS\_SECTION}

\item{\verb|  |status:NX\_CHAR=STATUS $\rightarrow$\\
\verb|  |\_NXattenuator.status STATUS}

\item{\verb|    |@time=TIME $\rightarrow$\\
\verb|    |\_NXattenuator.status\_\_time TIME}

\item{\verb|  |thickness:NX\_FLOAT=THICKNESS $\rightarrow$\\
\verb|  |\_NXattenuator.thickness THICKNESS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXattenuator.type TYPE}
\end{itemize}
\subsection{NXbeam}

Template of the state of the neutron or X-ray beam at any location. It will be referenced by beamline component groups within the NXinstrument group or by the NXsample group. Note that variables such as the incident energy could be scalar values or arrays. This group is especially valuable in storing the results of instrument simulations in which it is useful to specify the beam profile, time distribution etc. at each beamline component. Otherwise, its most likely use is in the NXsample group in which it defines the results of the neutron scattering by the sample, e.g., energy transfer, polarizations.

Note:  there has been a recent NIAC discussion on this class, in which Tobias Richter pointed out that
the polarization is unspecified, and the Stokes parameters would be 4 array position, not 2.  In addition,
there was a ``j'' index floating around and the 2-dimensional arrays appear to have been transposed.
The version has added the 2-parameter Denzo polarization parameters in the order
norm, then ratio.  In addition we have added the Stokes parameters in the order I, Q, U, V.
We propose that the unspecified polarization be deprecated.


\begin{verbatim}
NXbeam (base class, version 1.0)
  distance:NX_FLOAT
  energy_transfer:NX_FLOAT[i]
  final_beam_divergence:NX_FLOAT[i,2]
  final_energy:NX_FLOAT[i]
  final_polarization:NX_FLOAT[i,2]
  final_polarization_Denzo:NX_FLOAT[i,2]
  final_polarization_Stokes:NX_FLOAT[i,4]
  final_wavelength:NX_FLOAT[i]
  final_wavelength_spread:NX_FLOAT[i]
  flux:NX_FLOAT[i]
  incident_beam_divergence:NX_FLOAT[i,2]
  incident_energy:NX_FLOAT[i]
  incident_polarization:NX_FLOAT[i,2]
  incident_polarization_Denzo:NX_FLOAT[i,2]
  incident_polarization_Stokes:NX_FLOAT[i,4]
  incident_wavelength:NX_FLOAT[i]
  incident_wavelength_spread:NX_FLOAT[i]
  NXdata
\end{verbatim}

\begin{itemize}

\item{BEAM:NXbeam $\rightarrow$\\
\verb|  |\_NXbeam.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXbeam.NX\_id            BEAM\\
\verb|  |\_NXbeam.NX\_scan\_id      SCANID \\
\verb|  |\_NXbeam.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXbeam.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXbeam\_\_BEAM''
where BEAM is the name of this group, typically ``beam''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXbeam.distance DISTANCE\\
is an alias for\\
\verb|  |\_diffrn\_measurement.sample\_detector\_distance DISTANCE}

\item{\verb|  |energy\_transfer:NX\_FLOAT[i]=ENERGY\_TRANSFER $\rightarrow$\\
\verb|  |\_NXbeam.energy\_transfer ENERGY\_TRANSFER}

\item{\verb|  |final\_beam\_divergence:NX\_FLOAT[i,2]=FINAL\_BEAM\_DIVERGENCE $\rightarrow$\\
\verb|  |\_NXbeam.final\_beam\_divergence FINAL\_BEAM\_DIVERGENCE}

\item{\verb|  |final\_energy:NX\_FLOAT[i]=FINAL\_ENERGY $\rightarrow$\\
\verb|  |\_NXbeam.final\_energy FINAL\_ENERGY}

\item{\verb|  |final\_polarization:NX\_FLOAT[i,2]=FINAL\_POLARIZATION $\rightarrow$\\
\verb|  |\_NXbeam.final\_polarization FINAL\_POLARIZATION}

\item{\verb|  |final\_polarization\_Denzo:NX\_FLOAT[i,2]=FINAL\_POLARIZATION\_DENZO $\rightarrow$\\
\verb|  |\_NXbeam.final\_polarization FINAL\_POLARIZATION\_DENZO}

\item{\verb|  |final\_polarization\_Stokes:NX\_FLOAT[i,4]=FINAL\_POLARIZATION\_STOKES $\rightarrow$\\
\verb|  |\_NXbeam.final\_polarization FINAL\_POLARIZATION\_STOKES}

\item{\verb|  |final\_wavelength:NX\_FLOAT[i]=FINAL\_WAVELENGTH $\rightarrow$\\
\verb|  |\_NXbeam.final\_wavelength FINAL\_WAVELENGTH}

\item{\verb|  |final\_wavelength\_spread:NX\_FLOAT[i]=FINAL\_WAVELENGTH\_SPREAD $\rightarrow$\\
\verb|  |\_NXbeam.final\_wavelength\_spread FINAL\_WAVELENGTH\_SPREAD}

\item{\verb|  |flux:NX\_FLOAT[i]=FLUX $\rightarrow$\\
\verb|  |\_NXbeam.flux FLUX}

\item{\verb|  |incident\_beam\_divergence:NX\_FLOAT[i,2]=INCIDENT\_BEAM\_DIVERGENCE $\rightarrow$\\
\verb|  |\_NXbeam.incident\_beam\_divergence INCIDENT\_BEAM\_DIVERGENCE}

\item{\verb|  |incident\_energy:NX\_FLOAT[i]=INCIDENT\_ENERGY $\rightarrow$\\
\verb|  |\_NXbeam.incident\_energy INCIDENT\_ENERGY}

\item{\verb|  |incident\_polarization:NX\_FLOAT[i,2]=INCIDENT\_POLARIZATION $\rightarrow$\\
\verb|  |\_NXbeam.incident\_polarization INCIDENT\_POLARIZATION}

\item{\verb|  |incident\_polarization\_Denzo:NX\_FLOAT[i,4]=INCIDENT\_POLARIZATION\_DENZO $\rightarrow$\\
\verb|  |\_NXbeam.incident\_polarization\_Stokes INCIDENT\_POLARIZATION\_DENZO}

\item{\verb|  |incident\_polarization\_Stokes:NX\_FLOAT[i,4]=INCIDENT\_POLARIZATION\_STOKES $\rightarrow$\\
\verb|  |\_NXbeam.incident\_polarization\_Stokes INCIDENT\_POLARIZATION\_STOKES}

\item{\verb|  |incident\_wavelength:NX\_FLOAT[i]=INCIDENT\_WAVELENGTH $\rightarrow$\\
\verb|  |\_NXbeam.incident\_wavelength INCIDENT\_WAVELENGTH}

\item{\verb|  |incident\_wavelength\_spread:NX\_FLOAT[i]=INCIDENT\_WAVELENGTH\_SPREAD $\rightarrow$\\
\verb|  |\_NXbeam.incident\_wavelength\_spread INCIDENT\_WAVELENGTH\_SPREAD}

\item{data:NXdata $\rightarrow$\\
\verb|  |\_NXbeam.NXdata\_id data}
\end{itemize}

The final Denzo polarization from the beam component immediately prior to the beam being incident on 
the sample should agree with the values of the CBF tags \_diffrn\_radiation.polarizn\_source\_norm
and \_diffrn\_radiation.polarizn\_source\_ratio.

\subsection{NXbeam\_stop}

\begin{verbatim}

A class for a beamstop. Beamstops and their positions are important for SANS and SAXS experiments.

NXbeam_stop (base class, version 1.0)
  description:NX_CHAR
  distance_to_detector:NX_FLOAT
  size:NX_FLOAT
  status:NX_CHAR
  x:NX_FLOAT
  y:NX_FLOAT
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{BEAM\_STOP:NXbeam\_stop $\rightarrow$\\
\verb|  |\_NXbeam\_stop.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXbeam\_stop.NX\_id            BEAM\_STOP\\
\verb|  |\_NXbeam\_stop.NX\_scan\_id      SCANID \\
\verb|  |\_NXbeam\_stop.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXbeam\_stop.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXbeam\_stop\_\_BEAM\_STOP''
where BEAM\_STOP is the name of this group, typically ``beam\_stop''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXbeam\_stop.description DESCRIPTION}

\item{\verb|  |distance\_to\_detector:NX\_FLOAT=DISTANCE\_TO\_DETECTOR $\rightarrow$\\
\verb|  |\_NXbeam\_stop.distance\_to\_detector DISTANCE\_TO\_DETECTOR}

\item{\verb|  |size:NX\_FLOAT=SIZE $\rightarrow$\\
\verb|  |\_NXbeam\_stop.size SIZE}

\item{\verb|  |status:NX\_CHAR=STATUS $\rightarrow$\\
\verb|  |\_NXbeam\_stop.status STATUS}

\item{\verb|  |x:NX\_FLOAT=X $\rightarrow$\\
\verb|  |\_NXbeam\_stop.x X}

\item{\verb|  |y:NX\_FLOAT=Y $\rightarrow$\\
\verb|  |\_NXbeam\_stop.y Y}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXbeam\_stop.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXbending\_magnet}

\begin{verbatim}

description for a bending magnet


NXbending_magnet (base class, version 1.0)
  accepted_photon_beam_divergence:NX_FLOAT
  bending_radius:NX_FLOAT
  critical_energy:NX_FLOAT
  divergence_x_minus:NX_FLOAT
  divergence_x_plus:NX_FLOAT
  divergence_y_minus:NX_FLOAT
  divergence_y_plus:NX_FLOAT
  magnetic_field:NX_FLOAT
  source_distance_x:NX_FLOAT
  source_distance_y:NX_FLOAT
  spectrum:NXdata
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{BENDING\_MAGNET:NXbending\_magnet $\rightarrow$\\
\verb|  |\_NXbending\_magnet.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXbending\_magnet.NX\_id            BENDING\_MAGNET\\
\verb|  |\_NXbending\_magnet.NX\_scan\_id      SCANID \\
\verb|  |\_NXbending\_magnet.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXbending\_magnet.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXbending\_magnet\_\_BENDING\_MAGNET''
where BENDING\_MAGNET is the name of this group, typically ``bending\_magnet''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |accepted\_photon\_beam\_divergence:NX\_FLOAT=ACCEPTED\_PHOTON\_BEAM\_DIVERGENCE $\rightarrow$\\
\verb|  |\_NXbending\_magnet.accepted\_photon\_beam\_divergence ACCEPTED\_PHOTON\_BEAM\_DIVERGENCE}

\item{\verb|  |bending\_radius:NX\_FLOAT=BENDING\_RADIUS $\rightarrow$\\
\verb|  |\_NXbending\_magnet.bending\_radius BENDING\_RADIUS}

\item{\verb|  |critical\_energy:NX\_FLOAT=CRITICAL\_ENERGY $\rightarrow$\\
\verb|  |\_NXbending\_magnet.critical\_energy CRITICAL\_ENERGY}

\item{\verb|  |divergence\_x\_minus:NX\_FLOAT=DIVERGENCE\_X\_MINUS $\rightarrow$\\
\verb|  |\_NXbending\_magnet.divergence\_x\_minus DIVERGENCE\_X\_MINUS}

\item{\verb|  |divergence\_x\_plus:NX\_FLOAT=DIVERGENCE\_X\_PLUS $\rightarrow$\\
\verb|  |\_NXbending\_magnet.divergence\_x\_plus DIVERGENCE\_X\_PLUS}

\item{\verb|  |divergence\_y\_minus:NX\_FLOAT=DIVERGENCE\_Y\_MINUS $\rightarrow$\\
\verb|  |\_NXbending\_magnet.divergence\_y\_minus DIVERGENCE\_Y\_MINUS}

\item{\verb|  |divergence\_y\_plus:NX\_FLOAT=DIVERGENCE\_Y\_PLUS $\rightarrow$\\
\verb|  |\_NXbending\_magnet.divergence\_y\_plus DIVERGENCE\_Y\_PLUS}

\item{\verb|  |magnetic\_field:NX\_FLOAT=MAGNETIC\_FIELD $\rightarrow$\\
\verb|  |\_NXbending\_magnet.magnetic\_field MAGNETIC\_FIELD}

\item{\verb|  |source\_distance\_x:NX\_FLOAT=SOURCE\_DISTANCE\_X $\rightarrow$\\
\verb|  |\_NXbending\_magnet.source\_distance\_x SOURCE\_DISTANCE\_X}

\item{\verb|  |source\_distance\_y:NX\_FLOAT=SOURCE\_DISTANCE\_Y $\rightarrow$\\
\verb|  |\_NXbending\_magnet.source\_distance\_y SOURCE\_DISTANCE\_Y}

\item{spectrum:NXdata $\rightarrow$\\
\verb|  |\_NXbending\_magnet.NXdata\_id spectrum}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXbending\_magnet.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXcapillary}

This is a dictionary of field names to use for describing a capillary as used in X-ray beamlines. Based on information provided by Gerd Wellenreuther.

\begin{verbatim}
NXcapillary (base class, version 1.0)
  accepting_aperture:NX_FLOAT
  focal_size:NX_FLOAT
  manufacturer:NX_CHAR
  maximum_incident_angle:NX_FLOAT
  type:NX_CHAR
  working_distance:NX_FLOAT
  gain:NXdata
  transmission:NXdata
\end{verbatim}

\begin{itemize}

\item{CAPILLARY:NXcapillary $\rightarrow$\\
\verb|  |\_NXcapillary.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXcapillary.NX\_id            CAPILLARY\\
\verb|  |\_NXcapillary.NX\_scan\_id      SCANID \\
\verb|  |\_NXcapillary.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXcapillary.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXcapillary\_\_CAPILLARY''
where CAPILLARY is the name of this group, typically ``capillary''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |accepting\_aperture:NX\_FLOAT=ACCEPTING\_APERTURE $\rightarrow$\\
\verb|  |\_NXcapillary.accepting\_aperture ACCEPTING\_APERTURE}

\item{\verb|  |focal\_size:NX\_FLOAT=FOCAL\_SIZE $\rightarrow$\\
\verb|  |\_NXcapillary.focal\_size FOCAL\_SIZE}

\item{\verb|  |manufacturer:NX\_CHAR=MANUFACTURER $\rightarrow$\\
\verb|  |\_NXcapillary.manufacturer MANUFACTURER}

\item{\verb|  |maximum\_incident\_angle:NX\_FLOAT=MAXIMUM\_INCIDENT\_ANGLE $\rightarrow$\\
\verb|  |\_NXcapillary.maximum\_incident\_angle MAXIMUM\_INCIDENT\_ANGLE}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXcapillary.type TYPE}

\item{\verb|  |working\_distance:NX\_FLOAT=WORKING\_DISTANCE $\rightarrow$\\
\verb|  |\_NXcapillary.working\_distance WORKING\_DISTANCE}

\item{gain:NXdata $\rightarrow$\\
\verb|  |\_NXcapillary.NXdata\_id gain}

\item{transmission:NXdata $\rightarrow$\\
\verb|  |\_NXcapillary.NXdata\_id transmission}
\end{itemize}
\subsection{NXcharacterization}

note: This base class may be removed in future releases of NXDL. If you have a use for this base class, please provide a description of your intended use to the NIAC (nexus-committee@nexusformat.org).

\begin{verbatim}
NXcharacterization (base class, version 1.0)
  @source
  @location
  @mime_type
  definition:NX_CHAR
    @version
    @URL
\end{verbatim}

\begin{itemize}

\item{CHARACTERIZATION:NXcharacterization $\rightarrow$\\
\verb|  |\_NXcharacterization.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXcharacterization.NX\_id            CHARACTERIZATION\\
\verb|  |\_NXcharacterization.NX\_scan\_id      SCANID \\
\verb|  |\_NXcharacterization.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXcharacterization.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXcharacterization\_\_CHARACTERIZATION''
where CHARACTERIZATION is the name of this group, typically ``characterization''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |@source=SOURCE $\rightarrow$\\
\verb|    |\_NXcharacterization.NX\_class\_attribute\_\_source SOURCE}

\item{\verb|  |@location=LOCATION $\rightarrow$\\
\verb|    |\_NXcharacterization.NX\_class\_attribute\_\_location LOCATION}

\item{\verb|  |@mime\_type=MIME\_TYPE $\rightarrow$\\
\verb|    |\_NXcharacterization.NX\_class\_attribute\_\_mime\_type MIME\_TYPE}

\item{\verb|  |definition:NX\_CHAR=DEFINITION $\rightarrow$\\
\verb|  |\_NXcharacterization.definition DEFINITION}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXcharacterization.definition\_\_version VERSION}

\item{\verb|    |@URL=URL $\rightarrow$\\
\verb|    |\_NXcharacterization.definition\_\_URL URL}
\end{itemize}
\subsection{NXcollection}

Use NXcollection to gather together any set of terms. The original suggestion is to use this as a container class for the description of a beamline.

For NeXus validation, NXcollection will always generate a warning since it is always an optional group. Anything (groups, fields, or attributes) placed in an NXcollection group will not be validated.

\begin{verbatim}
NXcollection (contributed definition, version 1.0)
  beamline:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{COLLECTION:NXcollection $\rightarrow$\\
\verb|  |\_NXcollection.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXcollection.NX\_id            COLLECTION\\
\verb|  |\_NXcollection.NX\_scan\_id      SCANID \\
\verb|  |\_NXcollection.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXcollection.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXcollection\_\_COLLECTION''
where COLLECTION is the name of this group, typically ``collection''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |beamline:NX\_CHAR=BEAMLINE $\rightarrow$\\
\verb|  |\_NXcollection.beamline BEAMLINE}
\end{itemize}
\subsection{NXcollimator}

Template of a beamline collimator.

\begin{verbatim}
NXcollimator (base class, version 1.0)
  absorbing_material:NX_CHAR
  blade_spacing:NX_FLOAT
  blade_thickness:NX_FLOAT
  divergence_x:NX_FLOAT
  divergence_y:NX_FLOAT
  frequency:NX_FLOAT
  soller_angle:NX_FLOAT
  transmitting_material:NX_CHAR
  type:NX_CHAR
  NXgeometry
  frequency_log:NXlog
\end{verbatim}

\begin{itemize}

\item{COLLIMATOR:NXcollimator $\rightarrow$\\
\verb|  |\_NXcollimator.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXcollimator.NX\_id            COLLIMATOR\\
\verb|  |\_NXcollimator.NX\_scan\_id      SCANID \\
\verb|  |\_NXcollimator.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXcollimator.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXcollimator\_\_COLLIMATOR''
where COLLIMATOR is the name of this group, typically ``collimator''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |absorbing\_material:NX\_CHAR=ABSORBING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXcollimator.absorbing\_material ABSORBING\_MATERIAL}

\item{\verb|  |blade\_spacing:NX\_FLOAT=BLADE\_SPACING $\rightarrow$\\
\verb|  |\_NXcollimator.blade\_spacing BLADE\_SPACING}

\item{\verb|  |blade\_thickness:NX\_FLOAT=BLADE\_THICKNESS $\rightarrow$\\
\verb|  |\_NXcollimator.blade\_thickness BLADE\_THICKNESS}

\item{\verb|  |divergence\_x:NX\_FLOAT=DIVERGENCE\_X $\rightarrow$\\
\verb|  |\_NXcollimator.divergence\_x DIVERGENCE\_X}

\item{\verb|  |divergence\_y:NX\_FLOAT=DIVERGENCE\_Y $\rightarrow$\\
\verb|  |\_NXcollimator.divergence\_y DIVERGENCE\_Y}

\item{\verb|  |frequency:NX\_FLOAT=FREQUENCY $\rightarrow$\\
\verb|  |\_NXcollimator.frequency FREQUENCY}

\item{\verb|  |soller\_angle:NX\_FLOAT=SOLLER\_ANGLE $\rightarrow$\\
\verb|  |\_NXcollimator.soller\_angle SOLLER\_ANGLE}

\item{\verb|  |transmitting\_material:NX\_CHAR=TRANSMITTING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXcollimator.transmitting\_material TRANSMITTING\_MATERIAL}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXcollimator.type TYPE}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXcollimator.NXgeometry\_id geometry1}

\item{frequency\_log:NXlog $\rightarrow$\\
\verb|  |\_NXcollimator.NXlog\_id frequency\_log}
\end{itemize}

See also \_diffrn\_radiation.div\_x\_source and \_diffrn\_radiation.div\_y\_source

\subsection{NXcrystal}

Template of a crystal monochromator or analyzer. Permits double bent monochromator comprised of multiple segments with anisotropic Gaussian mosaic.

If curvatures are set to zero or are absent, array is considered to be flat.

Scattering vector is perpendicular to surface. Crystal is oriented parallel to beam incident on crystal before rotation, and lies in vertical plane.



\begin{verbatim}
NXcrystal (base class, version 1.0)
  azimuthal_angle:NX_FLOAT[i]
  bragg_angle:NX_FLOAT[i]
  chemical_formula:NX_CHAR
  curvature_horizontal:NX_FLOAT
  curvature_vertical:NX_FLOAT
  cut_angle:NX_FLOAT
  cylindrical_orientation_angle:NX_NUMBER
  d_spacing:NX_FLOAT
  density:NX_NUMBER
  is_cylindrical:NX_BOOLEAN
  mosaic_horizontal:NX_FLOAT
  mosaic_vertical:NX_FLOAT
  order_no:NX_INT
  orientation_matrix:NX_FLOAT[3,3]
  polar_angle:NX_FLOAT[i]
  reflection:NX_INT[3]
  scattering_vector:NX_FLOAT
  segment_columns:NX_FLOAT
  segment_gap:NX_FLOAT
  segment_height:NX_FLOAT
  segment_rows:NX_FLOAT
  segment_thickness:NX_FLOAT
  segment_width:NX_FLOAT
  space_group:NX_CHAR
  temperature:NX_FLOAT
  temperature_coefficient:NX_FLOAT
  thickness:NX_FLOAT
  type:NX_CHAR
  unit_cell:NX_FLOAT[n_comp,6]
  unit_cell_a:NX_FLOAT
  unit_cell_alpha:NX_FLOAT
  unit_cell_b:NX_FLOAT
  unit_cell_beta:NX_FLOAT
  unit_cell_c:NX_FLOAT
  unit_cell_gamma:NX_FLOAT
  unit_cell_volume:NX_FLOAT
  usage:NX_CHAR
  wavelength:NX_FLOAT[i]
  reflectivity:NXdata
  transmission:NXdata
  NXgeometry
  temperature_log:NXlog
  shape:NXshape
\end{verbatim}

\begin{itemize}

\item{CRYSTAL:NXcrystal $\rightarrow$\\
\verb|  |\_NXcrystal.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXcrystal.NX\_id            CRYSTAL\\
\verb|  |\_NXcrystal.NX\_scan\_id      SCANID \\
\verb|  |\_NXcrystal.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXcrystal.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXcrystal\_\_CRYSTAL''
where CRYSTAL is the name of this group, typically ``crystal''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |azimuthal\_angle:NX\_FLOAT[i]=AZIMUTHAL\_ANGLE $\rightarrow$\\
\verb|  |\_NXcrystal.azimuthal\_angle AZIMUTHAL\_ANGLE}

\item{\verb|  |bragg\_angle:NX\_FLOAT[i]=BRAGG\_ANGLE $\rightarrow$\\
\verb|  |\_NXcrystal.bragg\_angle BRAGG\_ANGLE}

\item{\verb|  |chemical\_formula:NX\_CHAR=CHEMICAL\_FORMULA $\rightarrow$\\
\verb|  |\_NXcrystal.chemical\_formula CHEMICAL\_FORMULA}

\item{\verb|  |curvature\_horizontal:NX\_FLOAT=CURVATURE\_HORIZONTAL $\rightarrow$\\
\verb|  |\_NXcrystal.curvature\_horizontal CURVATURE\_HORIZONTAL}

\item{\verb|  |curvature\_vertical:NX\_FLOAT=CURVATURE\_VERTICAL $\rightarrow$\\
\verb|  |\_NXcrystal.curvature\_vertical CURVATURE\_VERTICAL}

\item{\verb|  |cut\_angle:NX\_FLOAT=CUT\_ANGLE $\rightarrow$\\
\verb|  |\_NXcrystal.cut\_angle CUT\_ANGLE}

\item{\verb|  |cylindrical\_orientation\_angle:NX\_NUMBER=CYLINDRICAL\_ORIENTATION\_ANGLE $\rightarrow$\\
\verb|  |\_NXcrystal.cylindrical\_orientation\_angle CYLINDRICAL\_ORIENTATION\_ANGLE}

\item{\verb|  |d\_spacing:NX\_FLOAT=D\_SPACING $\rightarrow$\\
\verb|  |\_NXcrystal.d\_spacing D\_SPACING}

\item{\verb|  |density:NX\_NUMBER=DENSITY $\rightarrow$\\
\verb|  |\_NXcrystal.density DENSITY}

\item{\verb|  |is\_cylindrical:NX\_BOOLEAN=IS\_CYLINDRICAL $\rightarrow$\\
\verb|  |\_NXcrystal.is\_cylindrical IS\_CYLINDRICAL}

\item{\verb|  |mosaic\_horizontal:NX\_FLOAT=MOSAIC\_HORIZONTAL $\rightarrow$\\
\verb|  |\_NXcrystal.mosaic\_horizontal MOSAIC\_HORIZONTAL}

\item{\verb|  |mosaic\_vertical:NX\_FLOAT=MOSAIC\_VERTICAL $\rightarrow$\\
\verb|  |\_NXcrystal.mosaic\_vertical MOSAIC\_VERTICAL}

\item{\verb|  |order\_no:NX\_INT=ORDER\_NO $\rightarrow$\\
\verb|  |\_NXcrystal.order\_no ORDER\_NO}

\item{\verb|  |orientation\_matrix:NX\_FLOAT[3,3]=ORIENTATION\_MATRIX $\rightarrow$\\
\verb|  |\_NXcrystal.orientation\_matrix ORIENTATION\_MATRIX}

\item{\verb|  |polar\_angle:NX\_FLOAT[i]=POLAR\_ANGLE $\rightarrow$\\
\verb|  |\_NXcrystal.polar\_angle POLAR\_ANGLE}

\item{\verb|  |reflection:NX\_INT[3]=REFLECTION $\rightarrow$\\
\verb|  |\_NXcrystal.reflection REFLECTION}

\item{\verb|  |scattering\_vector:NX\_FLOAT=SCATTERING\_VECTOR $\rightarrow$\\
\verb|  |\_NXcrystal.scattering\_vector SCATTERING\_VECTOR}

\item{\verb|  |segment\_columns:NX\_FLOAT=SEGMENT\_COLUMNS $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_columns SEGMENT\_COLUMNS}

\item{\verb|  |segment\_gap:NX\_FLOAT=SEGMENT\_GAP $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_gap SEGMENT\_GAP}

\item{\verb|  |segment\_height:NX\_FLOAT=SEGMENT\_HEIGHT $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_height SEGMENT\_HEIGHT}

\item{\verb|  |segment\_rows:NX\_FLOAT=SEGMENT\_ROWS $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_rows SEGMENT\_ROWS}

\item{\verb|  |segment\_thickness:NX\_FLOAT=SEGMENT\_THICKNESS $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_thickness SEGMENT\_THICKNESS}

\item{\verb|  |segment\_width:NX\_FLOAT=SEGMENT\_WIDTH $\rightarrow$\\
\verb|  |\_NXcrystal.segment\_width SEGMENT\_WIDTH}

\item{\verb|  |space\_group:NX\_CHAR=SPACE\_GROUP $\rightarrow$\\
\verb|  |\_NXcrystal.space\_group SPACE\_GROUP}

\item{\verb|  |temperature:NX\_FLOAT=TEMPERATURE $\rightarrow$\\
\verb|  |\_NXcrystal.temperature TEMPERATURE}

\item{\verb|  |temperature\_coefficient:NX\_FLOAT=TEMPERATURE\_COEFFICIENT $\rightarrow$\\
\verb|  |\_NXcrystal.temperature\_coefficient TEMPERATURE\_COEFFICIENT}

\item{\verb|  |thickness:NX\_FLOAT=THICKNESS $\rightarrow$\\
\verb|  |\_NXcrystal.thickness THICKNESS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXcrystal.type TYPE}

\item{\verb|  |unit\_cell:NX\_FLOAT[n\_comp,6]=UNIT\_CELL $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell UNIT\_CELL}

\item{\verb|  |unit\_cell\_a:NX\_FLOAT=UNIT\_CELL\_A $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_a UNIT\_CELL\_A}

\item{\verb|  |unit\_cell\_alpha:NX\_FLOAT=UNIT\_CELL\_ALPHA $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_alpha UNIT\_CELL\_ALPHA}

\item{\verb|  |unit\_cell\_b:NX\_FLOAT=UNIT\_CELL\_B $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_b UNIT\_CELL\_B}

\item{\verb|  |unit\_cell\_beta:NX\_FLOAT=UNIT\_CELL\_BETA $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_beta UNIT\_CELL\_BETA}

\item{\verb|  |unit\_cell\_c:NX\_FLOAT=UNIT\_CELL\_C $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_c UNIT\_CELL\_C}

\item{\verb|  |unit\_cell\_gamma:NX\_FLOAT=UNIT\_CELL\_GAMMA $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_gamma UNIT\_CELL\_GAMMA}

\item{\verb|  |unit\_cell\_volume:NX\_FLOAT=UNIT\_CELL\_VOLUME $\rightarrow$\\
\verb|  |\_NXcrystal.unit\_cell\_volume UNIT\_CELL\_VOLUME}

\item{\verb|  |usage:NX\_CHAR=USAGE $\rightarrow$\\
\verb|  |\_NXcrystal.usage USAGE}

\item{\verb|  |wavelength:NX\_FLOAT[i]=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXcrystal.wavelength WAVELENGTH}

\item{reflectivity:NXdata $\rightarrow$\\
\verb|  |\_NXcrystal.NXdata\_id reflectivity}

\item{transmission:NXdata $\rightarrow$\\
\verb|  |\_NXcrystal.NXdata\_id transmission}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXcrystal.NXgeometry\_id geometry1}

\item{temperature\_log:NXlog $\rightarrow$\\
\verb|  |\_NXcrystal.NXlog\_id temperature\_log}

\item{shape:NXshape $\rightarrow$\\
\verb|  |\_NXcrystal.NXshape\_id shape}
\end{itemize}
\subsection{NXdata}

(required) NXdata is a template of plottable data and their dimension scales. It is mandatory that there is at least one NXdata group in each NXentry group. Note that the variable and data can be defined with different names. The signal and axes attribute of the data item define which items are plottable data and which are dimension scales.

    Each NXdata group will consist of only one data set containing plottable data and their standard deviations.
    This data set may be of arbitrary rank up to a maximum of NX\_MAXRANK=32.
    The plottable data will be identified by the attribute: signal=1
    The plottable data will identify the dimension scale specification(s) in the axes attribute.

If available, the standard deviations of the data are to be stored in a data set of the same rank and dimensions, with the name errors.

    For each data dimension, there should be a one-dimensional array of the same length.
    These one-dimensional arrays are the dimension scales of the data, i.e. the values of the independent variables at which the data is measured, such as scattering angle or energy transfer.

There are two methods of linking each data dimension to its respective dimension scale.

The preferred (and recommended) method uses the axes attribute to specify the names of each dimension scale.

The older method uses the axis attribute on each dimension scale to identify with an integer the axis whose value is the number of the dimension.

NXdata is used to implement one of the basic motivations in NeXus, to provide a default plot for the data of this NXentry. The actual data might be stored in another group and (hard) linked to the NXdata group.

\begin{verbatim}
NXdata (base class, version 1.0)
  data:NX_NUMBER[n]
    @signal
    @axes
    @uncertainties
    @long_name
  errors:NX_NUMBER[n]
  offset:NX_FLOAT
  scaling_factor:NX_FLOAT
  variable:NX_NUMBER[n]
    @long_name
    @distribution
    @first_good
    @last_good
    @axis
  variable_errors:NX_NUMBER[n]
  x:NX_FLOAT[nx]
  y:NX_FLOAT[ny]
  z:NX_FLOAT[nz]
\end{verbatim}

\begin{itemize}

\item{DATA:NXdata $\rightarrow$\\
\verb|  |\_NXdata.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXdata.NX\_id            DATA\\
\verb|  |\_NXdata.NX\_scan\_id      SCANID \\
\verb|  |\_NXdata.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXdata.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXdata\_\_DATA''
where DATA is the name of this group, typically ``data''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.\\
\verb|  |\_NXdata.NX\_id            DATA\\
is an alias for \\
\verb|  |\_array\_intensities.array\_id  DATA
and requires that we have a row in ARRAY\_DATA for which we have \\
\verb|  |\_array\_data.array\_id DATAID}

\item{\verb|  |data:NX\_NUMBER[n]=DATA $\rightarrow$\\
\verb|  |\_NXdata.data DATA \\
is an alias of \_array\_data.data DATA
for a row of ARRAY\_DATA for which we have
\verb|  |\_array\_data.array\_id DATAID}

\item{\verb|    |@signal=SIGNAL $\rightarrow$\\
\verb|    |\_NXdata.data\_\_signal SIGNAL}

\item{\verb|    |@axes=AXES $\rightarrow$\\
\verb|    |\_NXdata.data\_\_axes AXES}

\item{\verb|    |@uncertainties=UNCERTAINTIES $\rightarrow$\\
\verb|    |\_NXdata.data\_\_uncertainties UNCERTAINTIES}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdata.data\_\_long\_name LONG\_NAME}

\item{\verb|  |errors:NX\_NUMBER[n]=ERRORS $\rightarrow$\\
\verb|  |\_NXdata.errors ERRORS}

\item{\verb|  |offset:NX\_FLOAT=OFFSET $\rightarrow$\\
\verb|  |\_NXdata.offset OFFSET
is an alias for
\verb|  |\_array\_intensities.offset OFFSET
}

\item{\verb|  |scaling\_factor:NX\_FLOAT=SCALING\_FACTOR $\rightarrow$\\
\verb|  |\_NXdata.scaling\_factor SCALING\_FACTOR \\
is an alias for
\verb|  |\_array\_intensities.scaling SCALING\_FACTOR
}

\item{\verb|  |variable:NX\_NUMBER[n]=VARIABLE $\rightarrow$\\
\verb|  |\_NXdata.variable VARIABLE}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdata.variable\_\_long\_name LONG\_NAME}

\item{\verb|    |@distribution=DISTRIBUTION $\rightarrow$\\
\verb|    |\_NXdata.variable\_\_distribution DISTRIBUTION}

\item{\verb|    |@first\_good=FIRST\_GOOD $\rightarrow$\\
\verb|    |\_NXdata.variable\_\_first\_good FIRST\_GOOD}

\item{\verb|    |@last\_good=LAST\_GOOD $\rightarrow$\\
\verb|    |\_NXdata.variable\_\_last\_good LAST\_GOOD}

\item{\verb|    |@axis=AXIS $\rightarrow$\\
\verb|    |\_NXdata.variable\_\_axis AXIS}

\item{\verb|  |variable\_errors:NX\_NUMBER[n]=VARIABLE\_ERRORS $\rightarrow$\\
\verb|  |\_NXdata.variable\_errors VARIABLE\_ERRORS}

\item{\verb|  |x:NX\_FLOAT[nx]=X $\rightarrow$\\
\verb|  |\_NXdata.x X}

\item{\verb|  |y:NX\_FLOAT[ny]=Y $\rightarrow$\\
\verb|  |\_NXdata.y Y}

\item{\verb|  |z:NX\_FLOAT[nz]=Z $\rightarrow$\\
\verb|  |\_NXdata.z Z}
\end{itemize}

These items have a relationship with the CBF ARRAY\_INTENSITIES category,
as noted above as aliases,  Additional mappings into the various ARRAY
categories should be established.


\subsection{NXdetector}

Template of a detector, detector bank, or multidetector.



\begin{verbatim}
NXdetector (base class, version 1.0)
  acquisition_mode:NX_CHAR
  angular_calibration:NX_FLOAT[i,j]
  angular_calibration_applied:NX_BOOLEAN
  azimuthal_angle:NX_FLOAT[np,i,j]
  beam_center_x:NX_FLOAT
  beam_center_y:NX_FLOAT
  bit_depth_readout:NX_INT
  calibration_date:NX_DATE_TIME
  count_time:NX_NUMBER[np]
  countrate_correction__applied:NX_BOOLEAN
  crate:NX_INT[i,j]
    @local_name
  data:NX_NUMBER[np,i,j,tof]
    @signal
    @axes
    @long_name
    @check_sum
    @link
  data_error:NX_NUMBER[np,i,j,tof]
    @units
    @link
  dead_time:NX_FLOAT[np,i,j]
  description:NX_CHAR
  detection_gas_path:NX_FLOAT
  detector_number:NX_INT[i,j]
  detector_readout_time:NX_FLOAT
  diameter:NX_FLOAT
  distance:NX_FLOAT[np,i,j]
  flatfield:NX_FLOAT[i,j]
  flatfield_applied:NX_BOOLEAN
  flatfield_error:NX_FLOAT[i,j]
  frame_start_number:NX_INT
  frame_time:NX_FLOAT[NP]
  gain_setting:NX_CHAR
  gas_pressure:NX_FLOAT[i,j]
  input:NX_INT[i,j]
    @local_name
  layout:NX_CHAR
  local_name:NX_CHAR
  number_of_cycles:NX_INT
  pixel_mask:NX_FLOAT[i,j]
  pixel_mask_applied:NX_BOOLEAN
  polar_angle:NX_FLOAT[np,i,j]
  raw_time_of_flight:NX_INT[tof+1]
    @frequency
  saturation_value:NX_INT
  sensor_material:NX_CHAR
  sensor_thickness:NX_FLOAT
  sequence_number:NX_CHAR
  slot:NX_INT[i,j]
    @local_name
  solid_angle:NX_FLOAT[i,j]
  threshold_energy:NX_FLOAT
  time_of_flight:NX_FLOAT[tof+1]
    @axis
    @primary
    @long_name
    @link
  trigger_dead_time:NX_FLOAT
  trigger_delay_time:NX_FLOAT
  type:NX_CHAR
  x_pixel_offset:NX_FLOAT[i,j]
    @axis
    @primary
    @long_name
    @link
  x_pixel_size:NX_FLOAT[i,j]
  y_pixel_offset:NX_FLOAT[i,j]
    @axis
    @primary
    @long_name
  y_pixel_size:NX_FLOAT[i,j]
  NXcharacterization
  efficiency:NXdata
    efficiency:NX_FLOAT[i,j,k]
    real_time:NX_NUMBER[i,j,k]
    wavelength:NX_FLOAT[i,j,k]
  NXgeometry
  calibration_method:NXnote
  data_file:NXnote
\end{verbatim}

\begin{itemize}

\item{DETECTOR:NXdetector $\rightarrow$\\
\verb|  |\_NXdetector.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXdetector.NX\_id            DETECTOR\\
\verb|  |\_NXdetector.NX\_scan\_id      SCANID \\
\verb|  |\_NXdetector.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXdetector.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXdetector\_\_DETECTOR''
where DETECTOR is the name of this group, typically ``detector''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |acquisition\_mode:NX\_CHAR=ACQUISITION\_MODE $\rightarrow$\\
\verb|  |\_NXdetector.acquisition\_mode ACQUISITION\_MODE}

\item{\verb|  |angular\_calibration:NX\_FLOAT[i,j]=ANGULAR\_CALIBRATION $\rightarrow$\\
\verb|  |\_NXdetector.angular\_calibration ANGULAR\_CALIBRATION}

\item{\verb|  |angular\_calibration\_applied:NX\_BOOLEAN=ANGULAR\_CALIBRATION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.angular\_calibration\_applied ANGULAR\_CALIBRATION\_APPLIED}

\item{\verb|  |azimuthal\_angle:NX\_FLOAT[np,i,j]=AZIMUTHAL\_ANGLE $\rightarrow$\\
\verb|  |\_NXdetector.azimuthal\_angle AZIMUTHAL\_ANGLE}

\item{\verb|  |beam\_center\_x:NX\_FLOAT=BEAM\_CENTER\_X $\rightarrow$\\
\verb|  |\_NXdetector.beam\_center\_x BEAM\_CENTER\_X}

\item{\verb|  |beam\_center\_y:NX\_FLOAT=BEAM\_CENTER\_Y $\rightarrow$\\
\verb|  |\_NXdetector.beam\_center\_y BEAM\_CENTER\_Y}

\item{\verb|  |bit\_depth\_readout:NX\_INT=BIT\_DEPTH\_READOUT $\rightarrow$\\
\verb|  |\_NXdetector.bit\_depth\_readout BIT\_DEPTH\_READOUT}

\item{\verb|  |calibration\_date:NX\_DATE\_TIME=CALIBRATION\_DATE $\rightarrow$\\
\verb|  |\_NXdetector.calibration\_date CALIBRATION\_DATE}

\item{\verb|  |count\_time:NX\_NUMBER[np]=COUNT\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.count\_time COUNT\_TIME}

\item{\verb|  |countrate\_correction\_\_applied:NX\_BOOLEAN=COUNTRATE\_CORRECTION\_\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.countrate\_correction\_\_applied COUNTRATE\_CORRECTION\_\_APPLIED}

\item{\verb|  |crate:NX\_INT[i,j]=CRATE $\rightarrow$\\
\verb|  |\_NXdetector.crate CRATE}

\item{\verb|    |@local\_name=LOCAL\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.crate\_\_local\_name LOCAL\_NAME}

\item{\verb|  |data:NX\_NUMBER[np,i,j,tof]=DATA $\rightarrow$\\
\verb|  |\_NXdetector.data DATA}

\item{\verb|    |@signal=SIGNAL $\rightarrow$\\
\verb|    |\_NXdetector.data\_\_signal SIGNAL}

\item{\verb|    |@axes=AXES $\rightarrow$\\
\verb|    |\_NXdetector.data\_\_axes AXES}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.data\_\_long\_name LONG\_NAME}

\item{\verb|    |@check\_sum=CHECK\_SUM $\rightarrow$\\
\verb|    |\_NXdetector.data\_\_check\_sum CHECK\_SUM}

\item{\verb|    |@link=LINK $\rightarrow$\\
\verb|    |\_NXdetector.data\_\_link LINK}

\item{\verb|  |data\_error:NX\_NUMBER[np,i,j,tof]=DATA\_ERROR $\rightarrow$\\
\verb|  |\_NXdetector.data\_error DATA\_ERROR}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.data\_error\_\_units UNITS}

\item{\verb|    |@link=LINK $\rightarrow$\\
\verb|    |\_NXdetector.data\_error\_\_link LINK}

\item{\verb|  |dead\_time:NX\_FLOAT[np,i,j]=DEAD\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.dead\_time DEAD\_TIME\\
is an alias for\\
\verb|  |\_diffrn\_detector.dtime DEAD\_TIME}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXdetector.description DESCRIPTION}

\item{\verb|  |detection\_gas\_path:NX\_FLOAT=DETECTION\_GAS\_PATH $\rightarrow$\\
\verb|  |\_NXdetector.detection\_gas\_path DETECTION\_GAS\_PATH}

\item{\verb|  |detector\_number:NX\_INT[i,j]=DETECTOR\_NUMBER $\rightarrow$\\
\verb|  |\_NXdetector.detector\_number DETECTOR\_NUMBER}

\item{\verb|  |detector\_readout\_time:NX\_FLOAT=DETECTOR\_READOUT\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.detector\_readout\_time DETECTOR\_READOUT\_TIME}

\item{\verb|  |diameter:NX\_FLOAT=DIAMETER $\rightarrow$\\
\verb|  |\_NXdetector.diameter DIAMETER}

\item{\verb|  |distance:NX\_FLOAT[np,i,j]=DISTANCE $\rightarrow$\\
\verb|  |\_NXdetector.distance DISTANCE}

\item{\verb|  |flatfield:NX\_FLOAT[i,j]=FLATFIELD $\rightarrow$\\
\verb|  |\_NXdetector.flatfield FLATFIELD}

\item{\verb|  |flatfield\_applied:NX\_BOOLEAN=FLATFIELD\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.flatfield\_applied FLATFIELD\_APPLIED}

\item{\verb|  |flatfield\_error:NX\_FLOAT[i,j]=FLATFIELD\_ERROR $\rightarrow$\\
\verb|  |\_NXdetector.flatfield\_error FLATFIELD\_ERROR}

\item{\verb|  |frame\_start\_number:NX\_INT=FRAME\_START\_NUMBER $\rightarrow$\\
\verb|  |\_NXdetector.frame\_start\_number FRAME\_START\_NUMBER}

\item{\verb|  |frame\_time:NX\_FLOAT[NP]=FRAME\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.frame\_time FRAME\_TIME}

\item{\verb|  |gain\_setting:NX\_CHAR=GAIN\_SETTING $\rightarrow$\\
\verb|  |\_NXdetector.gain\_setting GAIN\_SETTING}

\item{\verb|  |gas\_pressure:NX\_FLOAT[i,j]=GAS\_PRESSURE $\rightarrow$\\
\verb|  |\_NXdetector.gas\_pressure GAS\_PRESSURE}

\item{\verb|  |input:NX\_INT[i,j]=INPUT $\rightarrow$\\
\verb|  |\_NXdetector.input INPUT}

\item{\verb|    |@local\_name=LOCAL\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.input\_\_local\_name LOCAL\_NAME}

\item{\verb|  |layout:NX\_CHAR=LAYOUT $\rightarrow$\\
\verb|  |\_NXdetector.layout LAYOUT}

\item{\verb|  |local\_name:NX\_CHAR=LOCAL\_NAME $\rightarrow$\\
\verb|  |\_NXdetector.local\_name LOCAL\_NAME}

\item{\verb|  |number\_of\_cycles:NX\_INT=NUMBER\_OF\_CYCLES $\rightarrow$\\
\verb|  |\_NXdetector.number\_of\_cycles NUMBER\_OF\_CYCLES}

\item{\verb|  |pixel\_mask:NX\_FLOAT[i,j]=PIXEL\_MASK $\rightarrow$\\
\verb|  |\_NXdetector.pixel\_mask PIXEL\_MASK}

\item{\verb|  |pixel\_mask\_applied:NX\_BOOLEAN=PIXEL\_MASK\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.pixel\_mask\_applied PIXEL\_MASK\_APPLIED}

\item{\verb|  |polar\_angle:NX\_FLOAT[np,i,j]=POLAR\_ANGLE $\rightarrow$\\
\verb|  |\_NXdetector.polar\_angle POLAR\_ANGLE}

\item{\verb|  |raw\_time\_of\_flight:NX\_INT[tof+1]=RAW\_TIME\_OF\_FLIGHT $\rightarrow$\\
\verb|  |\_NXdetector.raw\_time\_of\_flight RAW\_TIME\_OF\_FLIGHT}

\item{\verb|    |@frequency=FREQUENCY $\rightarrow$\\
\verb|    |\_NXdetector.raw\_time\_of\_flight\_\_frequency FREQUENCY}

\item{\verb|  |saturation\_value:NX\_INT=SATURATION\_VALUE $\rightarrow$\\
\verb|  |\_NXdetector.saturation\_value SATURATION\_VALUE}

\item{\verb|  |sensor\_material:NX\_CHAR=SENSOR\_MATERIAL $\rightarrow$\\
\verb|  |\_NXdetector.sensor\_material SENSOR\_MATERIAL}

\item{\verb|  |sensor\_thickness:NX\_FLOAT=SENSOR\_THICKNESS $\rightarrow$\\
\verb|  |\_NXdetector.sensor\_thickness SENSOR\_THICKNESS}

\item{\verb|  |sequence\_number:NX\_CHAR=SEQUENCE\_NUMBER $\rightarrow$\\
\verb|  |\_NXdetector.sequence\_number SEQUENCE\_NUMBER}

\item{\verb|  |slot:NX\_INT[i,j]=SLOT $\rightarrow$\\
\verb|  |\_NXdetector.slot SLOT}

\item{\verb|    |@local\_name=LOCAL\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.slot\_\_local\_name LOCAL\_NAME}

\item{\verb|  |solid\_angle:NX\_FLOAT[i,j]=SOLID\_ANGLE $\rightarrow$\\
\verb|  |\_NXdetector.solid\_angle SOLID\_ANGLE}

\item{\verb|  |threshold\_energy:NX\_FLOAT=THRESHOLD\_ENERGY $\rightarrow$\\
\verb|  |\_NXdetector.threshold\_energy THRESHOLD\_ENERGY}

\item{\verb|  |time\_of\_flight:NX\_FLOAT[tof+1]=TIME\_OF\_FLIGHT $\rightarrow$\\
\verb|  |\_NXdetector.time\_of\_flight TIME\_OF\_FLIGHT}

\item{\verb|    |@axis=AXIS $\rightarrow$\\
\verb|    |\_NXdetector.time\_of\_flight\_\_axis AXIS}

\item{\verb|    |@primary=PRIMARY $\rightarrow$\\
\verb|    |\_NXdetector.time\_of\_flight\_\_primary PRIMARY}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.time\_of\_flight\_\_long\_name LONG\_NAME}

\item{\verb|    |@link=LINK $\rightarrow$\\
\verb|    |\_NXdetector.time\_of\_flight\_\_link LINK}

\item{\verb|  |trigger\_dead\_time:NX\_FLOAT=TRIGGER\_DEAD\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.trigger\_dead\_time TRIGGER\_DEAD\_TIME}

\item{\verb|  |trigger\_delay\_time:NX\_FLOAT=TRIGGER\_DELAY\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.trigger\_delay\_time TRIGGER\_DELAY\_TIME}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXdetector.type TYPE}

\item{\verb|  |x\_pixel\_offset:NX\_FLOAT[i,j]=X\_PIXEL\_OFFSET $\rightarrow$\\
\verb|  |\_NXdetector.x\_pixel\_offset X\_PIXEL\_OFFSET}

\item{\verb|    |@axis=AXIS $\rightarrow$\\
\verb|    |\_NXdetector.x\_pixel\_offset\_\_axis AXIS}

\item{\verb|    |@primary=PRIMARY $\rightarrow$\\
\verb|    |\_NXdetector.x\_pixel\_offset\_\_primary PRIMARY}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.x\_pixel\_offset\_\_long\_name LONG\_NAME}

\item{\verb|    |@link=LINK $\rightarrow$\\
\verb|    |\_NXdetector.x\_pixel\_offset\_\_link LINK}

\item{\verb|  |x\_pixel\_size:NX\_FLOAT[i,j]=X\_PIXEL\_SIZE $\rightarrow$\\
\verb|  |\_NXdetector.x\_pixel\_size X\_PIXEL\_SIZE}

\item{\verb|  |y\_pixel\_offset:NX\_FLOAT[i,j]=Y\_PIXEL\_OFFSET $\rightarrow$\\
\verb|  |\_NXdetector.y\_pixel\_offset Y\_PIXEL\_OFFSET}

\item{\verb|    |@axis=AXIS $\rightarrow$\\
\verb|    |\_NXdetector.y\_pixel\_offset\_\_axis AXIS}

\item{\verb|    |@primary=PRIMARY $\rightarrow$\\
\verb|    |\_NXdetector.y\_pixel\_offset\_\_primary PRIMARY}

\item{\verb|    |@long\_name=LONG\_NAME $\rightarrow$\\
\verb|    |\_NXdetector.y\_pixel\_offset\_\_long\_name LONG\_NAME}

\item{\verb|  |y\_pixel\_size:NX\_FLOAT[i,j]=Y\_PIXEL\_SIZE $\rightarrow$\\
\verb|  |\_NXdetector.y\_pixel\_size Y\_PIXEL\_SIZE}

\item{characterization1:NXcharacterization $\rightarrow$\\
\verb|  |\_NXdetector.NXcharacterization\_id characterization1}

\item{efficiency:NXdata $\rightarrow$\\
\verb|  |\_NXdetector.NXdata\_id efficiency}

\item{\verb|    |efficiency:NX\_FLOAT[i,j,k]=EFFICIENCY $\rightarrow$\\
\verb|  |\_NXdetector.efficiency EFFICIENCY}

\item{\verb|    |real\_time:NX\_NUMBER[i,j,k]=REAL\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.real\_time REAL\_TIME}

\item{\verb|    |wavelength:NX\_FLOAT[i,j,k]=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXdetector.wavelength WAVELENGTH \\
is an alias for \\
\verb|  |\_diffrn\_radiation\_wavelength.wavelength WAVELENGTH}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXdetector.NXgeometry\_id geometry1}

\item{calibration\_method:NXnote $\rightarrow$\\
\verb|  |\_NXdetector.NXnote\_id calibration\_method}

\item{data\_file:NXnote $\rightarrow$\\
\verb|  |\_NXdetector.NXnote\_id data\_file}
\end{itemize}



\subsection{NXdetector\_group}

\begin{verbatim}
NXdetector_group (base class, version 1.0)
  group_index:NX_INT[i]
  group_names:NX_CHAR
  group_parent:NX_INT[]
  group_type:NX_INT[]
\end{verbatim}

\begin{itemize}

\item{DETECTOR\_GROUP:NXdetector\_group $\rightarrow$\\
\verb|  |\_NXdetector\_group.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXdetector\_group.NX\_id            DETECTOR\_GROUP\\
\verb|  |\_NXdetector\_group.NX\_scan\_id      SCANID \\
\verb|  |\_NXdetector\_group.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXdetector\_group.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXdetector\_group\_\_DETECTOR\_GROUP''
where DETECTOR\_GROUP is the name of this group, typically ``detector\_group''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |group\_index:NX\_INT[i]=GROUP\_INDEX $\rightarrow$\\
\verb|  |\_NXdetector\_group.group\_index GROUP\_INDEX}

\item{\verb|  |group\_names:NX\_CHAR=GROUP\_NAMES $\rightarrow$\\
\verb|  |\_NXdetector\_group.group\_names GROUP\_NAMES}

\item{\verb|  |group\_parent:NX\_INT[]=GROUP\_PARENT $\rightarrow$\\
\verb|  |\_NXdetector\_group.group\_parent GROUP\_PARENT}

\item{\verb|  |group\_type:NX\_INT[]=GROUP\_TYPE $\rightarrow$\\
\verb|  |\_NXdetector\_group.group\_type GROUP\_TYPE}
\end{itemize}

This is closely related to the DIFFRN\_DETECTOR\_ELEMENT category and
a method of integration needs to be found.

\subsection{NXdisk\_chopper}

\begin{verbatim}
NXdisk_chopper (base class, version 1.0)
  distance:NX_FLOAT
  pair_separation:NX_FLOAT
  phase:NX_FLOAT
  radius:NX_FLOAT
  ratio:NX_INT
  rotation_speed:NX_FLOAT
  slit_angle:NX_FLOAT
  slit_height:NX_FLOAT
  slits:NX_INT
  type:NX_CHAR
  wavelength_range:NX_FLOAT[2]
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{DISK\_CHOPPER:NXdisk\_chopper $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXdisk\_chopper.NX\_id            DISK\_CHOPPER\\
\verb|  |\_NXdisk\_chopper.NX\_scan\_id      SCANID \\
\verb|  |\_NXdisk\_chopper.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXdisk\_chopper.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXdisk\_chopper\_\_DISK\_CHOPPER''
where DISK\_CHOPPER is the name of this group, typically ``disk\_chopper''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.distance DISTANCE}

\item{\verb|  |pair\_separation:NX\_FLOAT=PAIR\_SEPARATION $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.pair\_separation PAIR\_SEPARATION}

\item{\verb|  |phase:NX\_FLOAT=PHASE $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.phase PHASE}

\item{\verb|  |radius:NX\_FLOAT=RADIUS $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.radius RADIUS}

\item{\verb|  |ratio:NX\_INT=RATIO $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.ratio RATIO}

\item{\verb|  |rotation\_speed:NX\_FLOAT=ROTATION\_SPEED $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.rotation\_speed ROTATION\_SPEED}

\item{\verb|  |slit\_angle:NX\_FLOAT=SLIT\_ANGLE $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.slit\_angle SLIT\_ANGLE}

\item{\verb|  |slit\_height:NX\_FLOAT=SLIT\_HEIGHT $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.slit\_height SLIT\_HEIGHT}

\item{\verb|  |slits:NX\_INT=SLITS $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.slits SLITS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.type TYPE}

\item{\verb|  |wavelength\_range:NX\_FLOAT[2]=WAVELENGTH\_RANGE $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.wavelength\_range WAVELENGTH\_RANGE}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXdisk\_chopper.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXentry}

\begin{verbatim}
NXentry (base class, version 1.0)
  @IDF_Version
  collection_description:NX_CHAR
  collection_identifier:NX_CHAR
  collection_time:NX_FLOAT
  definition:NX_CHAR
    @version
    @URL
  definition_local:NX_CHAR
    @version
    @URL
  duration:NX_INT
  end_time:NX_DATE_TIME
  entry_identifier:NX_CHAR
  experiment_description:NX_CHAR
  experiment_identifier:NX_CHAR
  pre_sample_flightpath:NX_FLOAT
  program_name:NX_CHAR
    @version
    @configuration
  revision:NX_CHAR
    @comment
  run_cycle:NX_CHAR
  start_time:NX_DATE_TIME
  title:NX_CHAR
  NXcharacterization
  NXdata
  NXinstrument
  NXmonitor
  experiment_documentation:NXnote
  notes:NXnote
  thumbnail:NXnote
    @mime_type
  NXprocess
  NXsample
  NXsubentry
  NXuser
\end{verbatim}

\begin{itemize}

\item{ENTRY:NXentry $\rightarrow$\\
\verb|  |\_NXentry.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXentry.NX\_id            ENTRY\\
\verb|  |\_NXentry.NX\_scan\_id      SCANID \\
\verb|  |\_NXentry.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXentry.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXentry\_\_ENTRY''
where ENTRY is the name of this group, typically ``entry''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |@IDF\_Version=IDF\_VERSION $\rightarrow$\\
\verb|    |\_NXentry.NX\_class\_attribute\_\_IDF\_Version IDF\_VERSION}

\item{\verb|  |collection\_description:NX\_CHAR=COLLECTION\_DESCRIPTION $\rightarrow$\\
\verb|  |\_NXentry.collection\_description COLLECTION\_DESCRIPTION}

\item{\verb|  |collection\_identifier:NX\_CHAR=COLLECTION\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXentry.collection\_identifier COLLECTION\_IDENTIFIER}

\item{\verb|  |collection\_time:NX\_FLOAT=COLLECTION\_TIME $\rightarrow$\\
\verb|  |\_NXentry.collection\_time COLLECTION\_TIME}

\item{\verb|  |definition:NX\_CHAR=DEFINITION $\rightarrow$\\
\verb|  |\_NXentry.definition DEFINITION}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXentry.definition\_\_version VERSION}

\item{\verb|    |@URL=URL $\rightarrow$\\
\verb|    |\_NXentry.definition\_\_URL URL}

\item{\verb|  |definition\_local:NX\_CHAR=DEFINITION\_LOCAL $\rightarrow$\\
\verb|  |\_NXentry.definition\_local DEFINITION\_LOCAL}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXentry.definition\_local\_\_version VERSION}

\item{\verb|    |@URL=URL $\rightarrow$\\
\verb|    |\_NXentry.definition\_local\_\_URL URL}

\item{\verb|  |duration:NX\_INT=DURATION $\rightarrow$\\
\verb|  |\_NXentry.duration DURATION}

\item{\verb|  |end\_time:NX\_DATE\_TIME=END\_TIME $\rightarrow$\\
\verb|  |\_NXentry.end\_time END\_TIME}

\item{\verb|  |entry\_identifier:NX\_CHAR=ENTRY\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXentry.entry\_identifier ENTRY\_IDENTIFIER}

\item{\verb|  |experiment\_description:NX\_CHAR=EXPERIMENT\_DESCRIPTION $\rightarrow$\\
\verb|  |\_NXentry.experiment\_description EXPERIMENT\_DESCRIPTION}

\item{\verb|  |experiment\_identifier:NX\_CHAR=EXPERIMENT\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXentry.experiment\_identifier EXPERIMENT\_IDENTIFIER}

\item{\verb|  |pre\_sample\_flightpath:NX\_FLOAT=PRE\_SAMPLE\_FLIGHTPATH $\rightarrow$\\
\verb|  |\_NXentry.pre\_sample\_flightpath PRE\_SAMPLE\_FLIGHTPATH}

\item{\verb|  |program\_name:NX\_CHAR=PROGRAM\_NAME $\rightarrow$\\
\verb|  |\_NXentry.program\_name PROGRAM\_NAME}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXentry.program\_name\_\_version VERSION}

\item{\verb|    |@configuration=CONFIGURATION $\rightarrow$\\
\verb|    |\_NXentry.program\_name\_\_configuration CONFIGURATION}

\item{\verb|  |revision:NX\_CHAR=REVISION $\rightarrow$\\
\verb|  |\_NXentry.revision REVISION}

\item{\verb|    |@comment=COMMENT $\rightarrow$\\
\verb|    |\_NXentry.revision\_\_comment COMMENT}

\item{\verb|  |run\_cycle:NX\_CHAR=RUN\_CYCLE $\rightarrow$\\
\verb|  |\_NXentry.run\_cycle RUN\_CYCLE}

\item{\verb|  |start\_time:NX\_DATE\_TIME=START\_TIME $\rightarrow$\\
\verb|  |\_NXentry.start\_time START\_TIME}

\item{\verb|  |title:NX\_CHAR=TITLE $\rightarrow$\\
\verb|  |\_NXentry.title TITLE}

\item{characterization1:NXcharacterization $\rightarrow$\\
\verb|  |\_NXentry.NXcharacterization\_id characterization1}

\item{data1:NXdata $\rightarrow$\\
\verb|  |\_NXentry.NXdata\_id data1}

\item{instrument1:NXinstrument $\rightarrow$\\
\verb|  |\_NXentry.NXinstrument\_id instrument1}

\item{monitor1:NXmonitor $\rightarrow$\\
\verb|  |\_NXentry.NXmonitor\_id monitor1}

\item{experiment\_documentation:NXnote $\rightarrow$\\
\verb|  |\_NXentry.NXnote\_id experiment\_documentation}

\item{notes:NXnote $\rightarrow$\\
\verb|  |\_NXentry.NXnote\_id notes}

\item{thumbnail:NXnote $\rightarrow$\\
\verb|  |\_NXentry.NXnote\_id thumbnail}

\item{\verb|    |@mime\_type=MIME\_TYPE $\rightarrow$\\
\verb|    |\_NXentry.title\_\_mime\_type MIME\_TYPE}

\item{process1:NXprocess $\rightarrow$\\
\verb|  |\_NXentry.NXprocess\_id process1}

\item{sample1:NXsample $\rightarrow$\\
\verb|  |\_NXentry.NXsample\_id sample1}

\item{subentry1:NXsubentry $\rightarrow$\\
\verb|  |\_NXentry.NXsubentry\_id subentry1}

\item{user1:NXuser $\rightarrow$\\
\verb|  |\_NXentry.NXuser\_id user1}
\end{itemize}
\subsection{NXenvironment}

\begin{verbatim}
NXenvironment (base class, version 1.0)
  description:NX_CHAR
  name:NX_CHAR
  program:NX_CHAR
  short_name:NX_CHAR
  type:NX_CHAR
  position:NXgeometry
  NXnote
  NXsensor
\end{verbatim}

\begin{itemize}

\item{ENVIRONMENT:NXenvironment $\rightarrow$\\
\verb|  |\_NXenvironment.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXenvironment.NX\_id            ENVIRONMENT\\
\verb|  |\_NXenvironment.NX\_scan\_id      SCANID \\
\verb|  |\_NXenvironment.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXenvironment.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXenvironment\_\_ENVIRONMENT''
where ENVIRONMENT is the name of this group, typically ``environment''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXenvironment.description DESCRIPTION}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXenvironment.name NAME}

\item{\verb|  |program:NX\_CHAR=PROGRAM $\rightarrow$\\
\verb|  |\_NXenvironment.program PROGRAM}

\item{\verb|  |short\_name:NX\_CHAR=SHORT\_NAME $\rightarrow$\\
\verb|  |\_NXenvironment.short\_name SHORT\_NAME}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXenvironment.type TYPE}

\item{position:NXgeometry $\rightarrow$\\
\verb|  |\_NXenvironment.NXgeometry\_id position}

\item{note1:NXnote $\rightarrow$\\
\verb|  |\_NXenvironment.NXnote\_id note1}

\item{sensor1:NXsensor $\rightarrow$\\
\verb|  |\_NXenvironment.NXsensor\_id sensor1}
\end{itemize}
\subsection{NXevent\_data}

\begin{verbatim}
NXevent_data (base class, version 1.0)
  events_per_pulse:NX_INT[j]
  pixel_number:NX_INT[i]
  pulse_height:NX_FLOAT[i,k]
  pulse_time:NX_INT[j]
    @offset
  time_of_flight:NX_INT[i]
\end{verbatim}

\begin{itemize}

\item{EVENT\_DATA:NXevent\_data $\rightarrow$\\
\verb|  |\_NXevent\_data.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXevent\_data.NX\_id            EVENT\_DATA\\
\verb|  |\_NXevent\_data.NX\_scan\_id      SCANID \\
\verb|  |\_NXevent\_data.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXevent\_data.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXevent\_data\_\_EVENT\_DATA''
where EVENT\_DATA is the name of this group, typically ``event\_data''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |events\_per\_pulse:NX\_INT[j]=EVENTS\_PER\_PULSE $\rightarrow$\\
\verb|  |\_NXevent\_data.events\_per\_pulse EVENTS\_PER\_PULSE}

\item{\verb|  |pixel\_number:NX\_INT[i]=PIXEL\_NUMBER $\rightarrow$\\
\verb|  |\_NXevent\_data.pixel\_number PIXEL\_NUMBER}

\item{\verb|  |pulse\_height:NX\_FLOAT[i,k]=PULSE\_HEIGHT $\rightarrow$\\
\verb|  |\_NXevent\_data.pulse\_height PULSE\_HEIGHT}

\item{\verb|  |pulse\_time:NX\_INT[j]=PULSE\_TIME $\rightarrow$\\
\verb|  |\_NXevent\_data.pulse\_time PULSE\_TIME}

\item{\verb|    |@offset=OFFSET $\rightarrow$\\
\verb|    |\_NXevent\_data.pulse\_time\_\_offset OFFSET}

\item{\verb|  |time\_of\_flight:NX\_INT[i]=TIME\_OF\_FLIGHT $\rightarrow$\\
\verb|  |\_NXevent\_data.time\_of\_flight TIME\_OF\_FLIGHT}
\end{itemize}
\subsection{NXfermi\_chopper}

\begin{verbatim}
NXfermi_chopper (base class, version 1.0)
  absorbing_material:NX_CHAR
  distance:NX_FLOAT
  energy:NX_FLOAT
  height:NX_FLOAT
  number:NX_INT
  r_slit:NX_FLOAT
  radius:NX_FLOAT
  rotation_speed:NX_FLOAT
  slit:NX_FLOAT
  transmitting_material:NX_CHAR
  type:NX_CHAR
  wavelength:NX_FLOAT
  width:NX_FLOAT
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{FERMI\_CHOPPER:NXfermi\_chopper $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXfermi\_chopper.NX\_id            FERMI\_CHOPPER\\
\verb|  |\_NXfermi\_chopper.NX\_scan\_id      SCANID \\
\verb|  |\_NXfermi\_chopper.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXfermi\_chopper.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXfermi\_chopper\_\_FERMI\_CHOPPER''
where FERMI\_CHOPPER is the name of this group, typically ``fermi\_chopper''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |absorbing\_material:NX\_CHAR=ABSORBING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.absorbing\_material ABSORBING\_MATERIAL}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.distance DISTANCE}

\item{\verb|  |energy:NX\_FLOAT=ENERGY $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.energy ENERGY}

\item{\verb|  |height:NX\_FLOAT=HEIGHT $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.height HEIGHT}

\item{\verb|  |number:NX\_INT=NUMBER $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.number NUMBER}

\item{\verb|  |r\_slit:NX\_FLOAT=R\_SLIT $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.r\_slit R\_SLIT}

\item{\verb|  |radius:NX\_FLOAT=RADIUS $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.radius RADIUS}

\item{\verb|  |rotation\_speed:NX\_FLOAT=ROTATION\_SPEED $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.rotation\_speed ROTATION\_SPEED}

\item{\verb|  |slit:NX\_FLOAT=SLIT $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.slit SLIT}

\item{\verb|  |transmitting\_material:NX\_CHAR=TRANSMITTING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.transmitting\_material TRANSMITTING\_MATERIAL}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.type TYPE}

\item{\verb|  |wavelength:NX\_FLOAT=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.wavelength WAVELENGTH}

\item{\verb|  |width:NX\_FLOAT=WIDTH $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.width WIDTH}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXfermi\_chopper.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXfilter}

\begin{verbatim}
NXfilter (base class, version 1.0)
  chemical_formula:NX_CHAR
  coating_material:NX_CHAR
  coating_roughness:NX_FLOAT[nsurf]
  density:NX_NUMBER
  description:NX_CHAR
  m_value:NX_FLOAT
  orientation_matrix:NX_FLOAT[n_comp,3,3]
  status:NX_CHAR
  substrate_material:NX_CHAR
  substrate_roughness:NX_FLOAT
  substrate_thickness:NX_FLOAT
  temperature:NX_FLOAT
  thickness:NX_FLOAT
  unit_cell_a:NX_FLOAT
  unit_cell_alpha:NX_FLOAT
  unit_cell_b:NX_FLOAT
  unit_cell_beta:NX_FLOAT
  unit_cell_c:NX_FLOAT
  unit_cell_gamma:NX_FLOAT
  unit_cell_volume:NX_FLOAT[n_comp]
  transmission:NXdata
  NXgeometry
  temperature_log:NXlog
  sensor_type:NXsensor
\end{verbatim}

\begin{itemize}

\item{FILTER:NXfilter $\rightarrow$\\
\verb|  |\_NXfilter.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXfilter.NX\_id            FILTER\\
\verb|  |\_NXfilter.NX\_scan\_id      SCANID \\
\verb|  |\_NXfilter.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXfilter.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXfilter\_\_FILTER''
where FILTER is the name of this group, typically ``filter''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |chemical\_formula:NX\_CHAR=CHEMICAL\_FORMULA $\rightarrow$\\
\verb|  |\_NXfilter.chemical\_formula CHEMICAL\_FORMULA}

\item{\verb|  |coating\_material:NX\_CHAR=COATING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXfilter.coating\_material COATING\_MATERIAL}

\item{\verb|  |coating\_roughness:NX\_FLOAT[nsurf]=COATING\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXfilter.coating\_roughness COATING\_ROUGHNESS}

\item{\verb|  |density:NX\_NUMBER=DENSITY $\rightarrow$\\
\verb|  |\_NXfilter.density DENSITY}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXfilter.description DESCRIPTION}

\item{\verb|  |m\_value:NX\_FLOAT=M\_VALUE $\rightarrow$\\
\verb|  |\_NXfilter.m\_value M\_VALUE}

\item{\verb|  |orientation\_matrix:NX\_FLOAT[n\_comp,3,3]=ORIENTATION\_MATRIX $\rightarrow$\\
\verb|  |\_NXfilter.orientation\_matrix ORIENTATION\_MATRIX}

\item{\verb|  |status:NX\_CHAR=STATUS $\rightarrow$\\
\verb|  |\_NXfilter.status STATUS}

\item{\verb|  |substrate\_material:NX\_CHAR=SUBSTRATE\_MATERIAL $\rightarrow$\\
\verb|  |\_NXfilter.substrate\_material SUBSTRATE\_MATERIAL}

\item{\verb|  |substrate\_roughness:NX\_FLOAT=SUBSTRATE\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXfilter.substrate\_roughness SUBSTRATE\_ROUGHNESS}

\item{\verb|  |substrate\_thickness:NX\_FLOAT=SUBSTRATE\_THICKNESS $\rightarrow$\\
\verb|  |\_NXfilter.substrate\_thickness SUBSTRATE\_THICKNESS}

\item{\verb|  |temperature:NX\_FLOAT=TEMPERATURE $\rightarrow$\\
\verb|  |\_NXfilter.temperature TEMPERATURE}

\item{\verb|  |thickness:NX\_FLOAT=THICKNESS $\rightarrow$\\
\verb|  |\_NXfilter.thickness THICKNESS}

\item{\verb|  |unit\_cell\_a:NX\_FLOAT=UNIT\_CELL\_A $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_a UNIT\_CELL\_A}

\item{\verb|  |unit\_cell\_alpha:NX\_FLOAT=UNIT\_CELL\_ALPHA $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_alpha UNIT\_CELL\_ALPHA}

\item{\verb|  |unit\_cell\_b:NX\_FLOAT=UNIT\_CELL\_B $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_b UNIT\_CELL\_B}

\item{\verb|  |unit\_cell\_beta:NX\_FLOAT=UNIT\_CELL\_BETA $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_beta UNIT\_CELL\_BETA}

\item{\verb|  |unit\_cell\_c:NX\_FLOAT=UNIT\_CELL\_C $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_c UNIT\_CELL\_C}

\item{\verb|  |unit\_cell\_gamma:NX\_FLOAT=UNIT\_CELL\_GAMMA $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_gamma UNIT\_CELL\_GAMMA}

\item{\verb|  |unit\_cell\_volume:NX\_FLOAT[n\_comp]=UNIT\_CELL\_VOLUME $\rightarrow$\\
\verb|  |\_NXfilter.unit\_cell\_volume UNIT\_CELL\_VOLUME}

\item{transmission:NXdata $\rightarrow$\\
\verb|  |\_NXfilter.NXdata\_id transmission}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXfilter.NXgeometry\_id geometry1}

\item{temperature\_log:NXlog $\rightarrow$\\
\verb|  |\_NXfilter.NXlog\_id temperature\_log}

\item{sensor\_type:NXsensor $\rightarrow$\\
\verb|  |\_NXfilter.NXsensor\_id sensor\_type}
\end{itemize}
\subsection{NXflipper}

\begin{verbatim}
NXflipper (base class, version 1.0)
  comp_current:NX_FLOAT
  comp_turns:NX_FLOAT
  flip_current:NX_FLOAT
  flip_turns:NX_FLOAT
  guide_current:NX_FLOAT
  guide_turns:NX_FLOAT
  thickness:NX_FLOAT
  type:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{FLIPPER:NXflipper $\rightarrow$\\
\verb|  |\_NXflipper.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXflipper.NX\_id            FLIPPER\\
\verb|  |\_NXflipper.NX\_scan\_id      SCANID \\
\verb|  |\_NXflipper.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXflipper.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXflipper\_\_FLIPPER''
where FLIPPER is the name of this group, typically ``flipper''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |comp\_current:NX\_FLOAT=COMP\_CURRENT $\rightarrow$\\
\verb|  |\_NXflipper.comp\_current COMP\_CURRENT}

\item{\verb|  |comp\_turns:NX\_FLOAT=COMP\_TURNS $\rightarrow$\\
\verb|  |\_NXflipper.comp\_turns COMP\_TURNS}

\item{\verb|  |flip\_current:NX\_FLOAT=FLIP\_CURRENT $\rightarrow$\\
\verb|  |\_NXflipper.flip\_current FLIP\_CURRENT}

\item{\verb|  |flip\_turns:NX\_FLOAT=FLIP\_TURNS $\rightarrow$\\
\verb|  |\_NXflipper.flip\_turns FLIP\_TURNS}

\item{\verb|  |guide\_current:NX\_FLOAT=GUIDE\_CURRENT $\rightarrow$\\
\verb|  |\_NXflipper.guide\_current GUIDE\_CURRENT}

\item{\verb|  |guide\_turns:NX\_FLOAT=GUIDE\_TURNS $\rightarrow$\\
\verb|  |\_NXflipper.guide\_turns GUIDE\_TURNS}

\item{\verb|  |thickness:NX\_FLOAT=THICKNESS $\rightarrow$\\
\verb|  |\_NXflipper.thickness THICKNESS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXflipper.type TYPE}
\end{itemize}
\subsection{NXgeometry}

\begin{verbatim}
NXgeometry (base class, version 1.0)
  component_index:NX_INT
  description:NX_CHAR
  NXorientation
  NXshape
  NXtranslation
\end{verbatim}

\begin{itemize}

\item{GEOMETRY:NXgeometry $\rightarrow$\\
\verb|  |\_NXgeometry.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXgeometry.NX\_id            GEOMETRY\\
\verb|  |\_NXgeometry.NX\_scan\_id      SCANID \\
\verb|  |\_NXgeometry.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXgeometry.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXgeometry\_\_GEOMETRY''
where GEOMETRY is the name of this group, typically ``geometry''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |component\_index:NX\_INT=COMPONENT\_INDEX $\rightarrow$\\
\verb|  |\_NXgeometry.component\_index COMPONENT\_INDEX}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXgeometry.description DESCRIPTION}

\item{orientation1:NXorientation $\rightarrow$\\
\verb|  |\_NXgeometry.NXorientation\_id orientation1}

\item{shape1:NXshape $\rightarrow$\\
\verb|  |\_NXgeometry.NXshape\_id shape1}

\item{translation1:NXtranslation $\rightarrow$\\
\verb|  |\_NXgeometry.NXtranslation\_id translation1}
\end{itemize}
\subsection{NXguide}

\begin{verbatim}
NXguide (base class, version 1.0)
  bend_angle_x:NX_FLOAT
  bend_angle_y:NX_FLOAT
  coating_material:NX_FLOAT[nsurf]
  coating_roughness:NX_FLOAT[nsurf]
  description:NX_CHAR
  external_material:NX_CHAR
  incident_angle:NX_FLOAT
  interior_atmosphere:NX_CHAR
  m_value:NX_FLOAT[nsurf]
  number_sections:NX_INT
  substrate_material:NX_FLOAT[nsurf]
  substrate_roughness:NX_FLOAT[nsurf]
  substrate_thickness:NX_FLOAT[nsurf]
  reflectivity:NXdata
    data:NX_NUMBER[nsurf,nwl]
      @signal
      @axes
    surface:NX_NUMBER[nsurf]
    wavelength:NX_NUMBER[nwl]
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{GUIDE:NXguide $\rightarrow$\\
\verb|  |\_NXguide.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXguide.NX\_id            GUIDE\\
\verb|  |\_NXguide.NX\_scan\_id      SCANID \\
\verb|  |\_NXguide.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXguide.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXguide\_\_GUIDE''
where GUIDE is the name of this group, typically ``guide''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |bend\_angle\_x:NX\_FLOAT=BEND\_ANGLE\_X $\rightarrow$\\
\verb|  |\_NXguide.bend\_angle\_x BEND\_ANGLE\_X}

\item{\verb|  |bend\_angle\_y:NX\_FLOAT=BEND\_ANGLE\_Y $\rightarrow$\\
\verb|  |\_NXguide.bend\_angle\_y BEND\_ANGLE\_Y}

\item{\verb|  |coating\_material:NX\_FLOAT[nsurf]=COATING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXguide.coating\_material COATING\_MATERIAL}

\item{\verb|  |coating\_roughness:NX\_FLOAT[nsurf]=COATING\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXguide.coating\_roughness COATING\_ROUGHNESS}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXguide.description DESCRIPTION}

\item{\verb|  |external\_material:NX\_CHAR=EXTERNAL\_MATERIAL $\rightarrow$\\
\verb|  |\_NXguide.external\_material EXTERNAL\_MATERIAL}

\item{\verb|  |incident\_angle:NX\_FLOAT=INCIDENT\_ANGLE $\rightarrow$\\
\verb|  |\_NXguide.incident\_angle INCIDENT\_ANGLE}

\item{\verb|  |interior\_atmosphere:NX\_CHAR=INTERIOR\_ATMOSPHERE $\rightarrow$\\
\verb|  |\_NXguide.interior\_atmosphere INTERIOR\_ATMOSPHERE}

\item{\verb|  |m\_value:NX\_FLOAT[nsurf]=M\_VALUE $\rightarrow$\\
\verb|  |\_NXguide.m\_value M\_VALUE}

\item{\verb|  |number\_sections:NX\_INT=NUMBER\_SECTIONS $\rightarrow$\\
\verb|  |\_NXguide.number\_sections NUMBER\_SECTIONS}

\item{\verb|  |substrate\_material:NX\_FLOAT[nsurf]=SUBSTRATE\_MATERIAL $\rightarrow$\\
\verb|  |\_NXguide.substrate\_material SUBSTRATE\_MATERIAL}

\item{\verb|  |substrate\_roughness:NX\_FLOAT[nsurf]=SUBSTRATE\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXguide.substrate\_roughness SUBSTRATE\_ROUGHNESS}

\item{\verb|  |substrate\_thickness:NX\_FLOAT[nsurf]=SUBSTRATE\_THICKNESS $\rightarrow$\\
\verb|  |\_NXguide.substrate\_thickness SUBSTRATE\_THICKNESS}

\item{reflectivity:NXdata $\rightarrow$\\
\verb|  |\_NXguide.NXdata\_id reflectivity}

\item{\verb|    |data:NX\_NUMBER[nsurf,nwl]=DATA $\rightarrow$\\
\verb|  |\_NXguide.data DATA}

\item{\verb|      |@signal=SIGNAL $\rightarrow$\\
\verb|    |\_NXguide.data\_\_signal SIGNAL}

\item{\verb|      |@axes=AXES $\rightarrow$\\
\verb|    |\_NXguide.data\_\_axes AXES}

\item{\verb|    |surface:NX\_NUMBER[nsurf]=SURFACE $\rightarrow$\\
\verb|  |\_NXguide.surface SURFACE}

\item{\verb|    |wavelength:NX\_NUMBER[nwl]=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXguide.wavelength WAVELENGTH}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXguide.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXinsertion\_device}

\begin{verbatim}
NXinsertion_device (base class, version 1.0)
  bandwidth:NX_FLOAT
  energy:NX_FLOAT
  gap:NX_FLOAT
  harmonic:NX_INT
  k:NX_FLOAT
  length:NX_FLOAT
  magnetic_wavelength:NX_FLOAT
  phase:NX_FLOAT
  poles:NX_INT
  power:NX_FLOAT
  taper:NX_FLOAT
  type:NX_CHAR
  spectrum:NXdata
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{INSERTION\_DEVICE:NXinsertion\_device $\rightarrow$\\
\verb|  |\_NXinsertion\_device.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXinsertion\_device.NX\_id            INSERTION\_DEVICE\\
\verb|  |\_NXinsertion\_device.NX\_scan\_id      SCANID \\
\verb|  |\_NXinsertion\_device.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXinsertion\_device.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXinsertion\_device\_\_INSERTION\_DEVICE''
where INSERTION\_DEVICE is the name of this group, typically ``insertion\_device''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |bandwidth:NX\_FLOAT=BANDWIDTH $\rightarrow$\\
\verb|  |\_NXinsertion\_device.bandwidth BANDWIDTH}

\item{\verb|  |energy:NX\_FLOAT=ENERGY $\rightarrow$\\
\verb|  |\_NXinsertion\_device.energy ENERGY}

\item{\verb|  |gap:NX\_FLOAT=GAP $\rightarrow$\\
\verb|  |\_NXinsertion\_device.gap GAP}

\item{\verb|  |harmonic:NX\_INT=HARMONIC $\rightarrow$\\
\verb|  |\_NXinsertion\_device.harmonic HARMONIC}

\item{\verb|  |k:NX\_FLOAT=K $\rightarrow$\\
\verb|  |\_NXinsertion\_device.k K}

\item{\verb|  |length:NX\_FLOAT=LENGTH $\rightarrow$\\
\verb|  |\_NXinsertion\_device.length LENGTH}

\item{\verb|  |magnetic\_wavelength:NX\_FLOAT=MAGNETIC\_WAVELENGTH $\rightarrow$\\
\verb|  |\_NXinsertion\_device.magnetic\_wavelength MAGNETIC\_WAVELENGTH}

\item{\verb|  |phase:NX\_FLOAT=PHASE $\rightarrow$\\
\verb|  |\_NXinsertion\_device.phase PHASE}

\item{\verb|  |poles:NX\_INT=POLES $\rightarrow$\\
\verb|  |\_NXinsertion\_device.poles POLES}

\item{\verb|  |power:NX\_FLOAT=POWER $\rightarrow$\\
\verb|  |\_NXinsertion\_device.power POWER}

\item{\verb|  |taper:NX\_FLOAT=TAPER $\rightarrow$\\
\verb|  |\_NXinsertion\_device.taper TAPER}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXinsertion\_device.type TYPE}

\item{spectrum:NXdata $\rightarrow$\\
\verb|  |\_NXinsertion\_device.NXdata\_id spectrum}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXinsertion\_device.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXinstrument}

\begin{verbatim}
NXinstrument (base class, version 1.0)
  name:NX_CHAR
    @short_name
  NXaperture
  NXattenuator
  NXbeam
  NXbeam_stop
  NXbending_magnet
  NXcollimator
  NXcrystal
  NXdetector
  NXdisk_chopper
  NXfermi_chopper
  NXfilter
  NXflipper
  NXguide
  NXinsertion_device
  NXmirror
  NXmoderator
  NXpolarizer
  NXsource
  NXvelocity_selector
\end{verbatim}

\begin{itemize}

\item{INSTRUMENT:NXinstrument $\rightarrow$\\
\verb|  |\_NXinstrument.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXinstrument.NX\_id            INSTRUMENT\\
\verb|  |\_NXinstrument.NX\_scan\_id      SCANID \\
\verb|  |\_NXinstrument.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXinstrument.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXinstrument\_\_INSTRUMENT''
where INSTRUMENT is the name of this group, typically ``instrument''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXinstrument.name NAME}

\item{\verb|    |@short\_name=SHORT\_NAME $\rightarrow$\\
\verb|    |\_NXinstrument.name\_\_short\_name SHORT\_NAME}

\item{aperture1:NXaperture $\rightarrow$\\
\verb|  |\_NXinstrument.NXaperture\_id aperture1}

\item{attenuator1:NXattenuator $\rightarrow$\\
\verb|  |\_NXinstrument.NXattenuator\_id attenuator1}

\item{beam1:NXbeam $\rightarrow$\\
\verb|  |\_NXinstrument.NXbeam\_id beam1}

\item{beam\_stop1:NXbeam\_stop $\rightarrow$\\
\verb|  |\_NXinstrument.NXbeam\_stop\_id beam\_stop1}

\item{bending\_magnet1:NXbending\_magnet $\rightarrow$\\
\verb|  |\_NXinstrument.NXbending\_magnet\_id bending\_magnet1}

\item{collimator1:NXcollimator $\rightarrow$\\
\verb|  |\_NXinstrument.NXcollimator\_id collimator1}

\item{crystal1:NXcrystal $\rightarrow$\\
\verb|  |\_NXinstrument.NXcrystal\_id crystal1}

\item{detector1:NXdetector $\rightarrow$\\
\verb|  |\_NXinstrument.NXdetector\_id detector1}

\item{disk\_chopper1:NXdisk\_chopper $\rightarrow$\\
\verb|  |\_NXinstrument.NXdisk\_chopper\_id disk\_chopper1}

\item{fermi\_chopper1:NXfermi\_chopper $\rightarrow$\\
\verb|  |\_NXinstrument.NXfermi\_chopper\_id fermi\_chopper1}

\item{filter1:NXfilter $\rightarrow$\\
\verb|  |\_NXinstrument.NXfilter\_id filter1}

\item{flipper1:NXflipper $\rightarrow$\\
\verb|  |\_NXinstrument.NXflipper\_id flipper1}

\item{guide1:NXguide $\rightarrow$\\
\verb|  |\_NXinstrument.NXguide\_id guide1}

\item{insertion\_device1:NXinsertion\_device $\rightarrow$\\
\verb|  |\_NXinstrument.NXinsertion\_device\_id insertion\_device1}

\item{mirror1:NXmirror $\rightarrow$\\
\verb|  |\_NXinstrument.NXmirror\_id mirror1}

\item{moderator1:NXmoderator $\rightarrow$\\
\verb|  |\_NXinstrument.NXmoderator\_id moderator1}

\item{polarizer1:NXpolarizer $\rightarrow$\\
\verb|  |\_NXinstrument.NXpolarizer\_id polarizer1}

\item{source1:NXsource $\rightarrow$\\
\verb|  |\_NXinstrument.NXsource\_id source1}

\item{velocity\_selector1:NXvelocity\_selector $\rightarrow$\\
\verb|  |\_NXinstrument.NXvelocity\_selector\_id velocity\_selector1}
\end{itemize}
\subsection{NXlog}

\begin{verbatim}
NXlog (base class, version 1.0)
  average_value:NX_FLOAT
  average_value_error:NX_FLOAT
  description:NX_CHAR
  duration:NX_FLOAT
  maximum_value:NX_FLOAT
  minimum_value:NX_FLOAT
  raw_value:NX_NUMBER
  time:NX_FLOAT
    @start
  value:NX_NUMBER
\end{verbatim}

\begin{itemize}

\item{LOG:NXlog $\rightarrow$\\
\verb|  |\_NXlog.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXlog.NX\_id            LOG\\
\verb|  |\_NXlog.NX\_scan\_id      SCANID \\
\verb|  |\_NXlog.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXlog.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXlog\_\_LOG''
where LOG is the name of this group, typically ``log''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |average\_value:NX\_FLOAT=AVERAGE\_VALUE $\rightarrow$\\
\verb|  |\_NXlog.average\_value AVERAGE\_VALUE}

\item{\verb|  |average\_value\_error:NX\_FLOAT=AVERAGE\_VALUE\_ERROR $\rightarrow$\\
\verb|  |\_NXlog.average\_value\_error AVERAGE\_VALUE\_ERROR}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXlog.description DESCRIPTION}

\item{\verb|  |duration:NX\_FLOAT=DURATION $\rightarrow$\\
\verb|  |\_NXlog.duration DURATION}

\item{\verb|  |maximum\_value:NX\_FLOAT=MAXIMUM\_VALUE $\rightarrow$\\
\verb|  |\_NXlog.maximum\_value MAXIMUM\_VALUE}

\item{\verb|  |minimum\_value:NX\_FLOAT=MINIMUM\_VALUE $\rightarrow$\\
\verb|  |\_NXlog.minimum\_value MINIMUM\_VALUE}

\item{\verb|  |raw\_value:NX\_NUMBER=RAW\_VALUE $\rightarrow$\\
\verb|  |\_NXlog.raw\_value RAW\_VALUE}

\item{\verb|  |time:NX\_FLOAT=TIME $\rightarrow$\\
\verb|  |\_NXlog.time TIME}

\item{\verb|    |@start=START $\rightarrow$\\
\verb|    |\_NXlog.time\_\_start START}

\item{\verb|  |value:NX\_NUMBER=VALUE $\rightarrow$\\
\verb|  |\_NXlog.value VALUE}
\end{itemize}
\subsection{NXmirror}

\begin{verbatim}
NXmirror (base class, version 1.0)
  bend_angle_x:NX_FLOAT
  bend_angle_y:NX_FLOAT
  coating_material:NX_CHAR
  coating_roughness:NX_FLOAT
  description:NX_CHAR
  even_layer_density:NX_FLOAT
  even_layer_material:NX_CHAR
  external_material:NX_CHAR
  incident_angle:NX_FLOAT
  interior_atmosphere:NX_CHAR
  layer_thickness:NX_FLOAT
  m_value:NX_FLOAT
  odd_layer_density:NX_FLOAT
  odd_layer_material:NX_CHAR
  substrate_density:NX_FLOAT
  substrate_material:NX_CHAR
  substrate_roughness:NX_FLOAT
  substrate_thickness:NX_FLOAT
  type:NX_CHAR
  reflectivity:NXdata
  figure_data:NXdata
  NXgeometry
  shape:NXshape
\end{verbatim}

\begin{itemize}

\item{MIRROR:NXmirror $\rightarrow$\\
\verb|  |\_NXmirror.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXmirror.NX\_id            MIRROR\\
\verb|  |\_NXmirror.NX\_scan\_id      SCANID \\
\verb|  |\_NXmirror.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXmirror.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXmirror\_\_MIRROR''
where MIRROR is the name of this group, typically ``mirror''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |bend\_angle\_x:NX\_FLOAT=BEND\_ANGLE\_X $\rightarrow$\\
\verb|  |\_NXmirror.bend\_angle\_x BEND\_ANGLE\_X}

\item{\verb|  |bend\_angle\_y:NX\_FLOAT=BEND\_ANGLE\_Y $\rightarrow$\\
\verb|  |\_NXmirror.bend\_angle\_y BEND\_ANGLE\_Y}

\item{\verb|  |coating\_material:NX\_CHAR=COATING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmirror.coating\_material COATING\_MATERIAL}

\item{\verb|  |coating\_roughness:NX\_FLOAT=COATING\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXmirror.coating\_roughness COATING\_ROUGHNESS}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXmirror.description DESCRIPTION}

\item{\verb|  |even\_layer\_density:NX\_FLOAT=EVEN\_LAYER\_DENSITY $\rightarrow$\\
\verb|  |\_NXmirror.even\_layer\_density EVEN\_LAYER\_DENSITY}

\item{\verb|  |even\_layer\_material:NX\_CHAR=EVEN\_LAYER\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmirror.even\_layer\_material EVEN\_LAYER\_MATERIAL}

\item{\verb|  |external\_material:NX\_CHAR=EXTERNAL\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmirror.external\_material EXTERNAL\_MATERIAL}

\item{\verb|  |incident\_angle:NX\_FLOAT=INCIDENT\_ANGLE $\rightarrow$\\
\verb|  |\_NXmirror.incident\_angle INCIDENT\_ANGLE}

\item{\verb|  |interior\_atmosphere:NX\_CHAR=INTERIOR\_ATMOSPHERE $\rightarrow$\\
\verb|  |\_NXmirror.interior\_atmosphere INTERIOR\_ATMOSPHERE}

\item{\verb|  |layer\_thickness:NX\_FLOAT=LAYER\_THICKNESS $\rightarrow$\\
\verb|  |\_NXmirror.layer\_thickness LAYER\_THICKNESS}

\item{\verb|  |m\_value:NX\_FLOAT=M\_VALUE $\rightarrow$\\
\verb|  |\_NXmirror.m\_value M\_VALUE}

\item{\verb|  |odd\_layer\_density:NX\_FLOAT=ODD\_LAYER\_DENSITY $\rightarrow$\\
\verb|  |\_NXmirror.odd\_layer\_density ODD\_LAYER\_DENSITY}

\item{\verb|  |odd\_layer\_material:NX\_CHAR=ODD\_LAYER\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmirror.odd\_layer\_material ODD\_LAYER\_MATERIAL}

\item{\verb|  |substrate\_density:NX\_FLOAT=SUBSTRATE\_DENSITY $\rightarrow$\\
\verb|  |\_NXmirror.substrate\_density SUBSTRATE\_DENSITY}

\item{\verb|  |substrate\_material:NX\_CHAR=SUBSTRATE\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmirror.substrate\_material SUBSTRATE\_MATERIAL}

\item{\verb|  |substrate\_roughness:NX\_FLOAT=SUBSTRATE\_ROUGHNESS $\rightarrow$\\
\verb|  |\_NXmirror.substrate\_roughness SUBSTRATE\_ROUGHNESS}

\item{\verb|  |substrate\_thickness:NX\_FLOAT=SUBSTRATE\_THICKNESS $\rightarrow$\\
\verb|  |\_NXmirror.substrate\_thickness SUBSTRATE\_THICKNESS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXmirror.type TYPE}

\item{reflectivity:NXdata $\rightarrow$\\
\verb|  |\_NXmirror.NXdata\_id reflectivity}

\item{figure\_data:NXdata $\rightarrow$\\
\verb|  |\_NXmirror.NXdata\_id figure\_data}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXmirror.NXgeometry\_id geometry1}

\item{shape:NXshape $\rightarrow$\\
\verb|  |\_NXmirror.NXshape\_id shape}
\end{itemize}
\subsection{NXmoderator}

\begin{verbatim}
NXmoderator (base class, version 1.0)
  coupled:NX_BOOLEAN
  coupling_material:NX_CHAR
  distance:NX_FLOAT
  poison_depth:NX_FLOAT
  poison_material:NX_CHAR
  temperature:NX_FLOAT
  type:NX_CHAR
  pulse_shape:NXdata
  NXgeometry
  temperature_log:NXlog
\end{verbatim}

\begin{itemize}

\item{MODERATOR:NXmoderator $\rightarrow$\\
\verb|  |\_NXmoderator.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXmoderator.NX\_id            MODERATOR\\
\verb|  |\_NXmoderator.NX\_scan\_id      SCANID \\
\verb|  |\_NXmoderator.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXmoderator.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXmoderator\_\_MODERATOR''
where MODERATOR is the name of this group, typically ``moderator''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |coupled:NX\_BOOLEAN=COUPLED $\rightarrow$\\
\verb|  |\_NXmoderator.coupled COUPLED}

\item{\verb|  |coupling\_material:NX\_CHAR=COUPLING\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmoderator.coupling\_material COUPLING\_MATERIAL}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXmoderator.distance DISTANCE}

\item{\verb|  |poison\_depth:NX\_FLOAT=POISON\_DEPTH $\rightarrow$\\
\verb|  |\_NXmoderator.poison\_depth POISON\_DEPTH}

\item{\verb|  |poison\_material:NX\_CHAR=POISON\_MATERIAL $\rightarrow$\\
\verb|  |\_NXmoderator.poison\_material POISON\_MATERIAL}

\item{\verb|  |temperature:NX\_FLOAT=TEMPERATURE $\rightarrow$\\
\verb|  |\_NXmoderator.temperature TEMPERATURE}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXmoderator.type TYPE}

\item{pulse\_shape:NXdata $\rightarrow$\\
\verb|  |\_NXmoderator.NXdata\_id pulse\_shape}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXmoderator.NXgeometry\_id geometry1}

\item{temperature\_log:NXlog $\rightarrow$\\
\verb|  |\_NXmoderator.NXlog\_id temperature\_log}
\end{itemize}
\subsection{NXmonitor}

\begin{verbatim}
NXmonitor (base class, version 1.0)
  count_time:NX_FLOAT
  data:NX_NUMBER[n]
    @signal
    @axes
  distance:NX_FLOAT
  efficiency:NX_NUMBER[]
  end_time:NX_DATE_TIME
  integral:NX_NUMBER
  mode:NX_CHAR
  preset:NX_NUMBER
  range:NX_FLOAT[2]
  sampled_fraction:NX_FLOAT
  start_time:NX_DATE_TIME
  time_of_flight:NX_FLOAT[]
  type:NX_CHAR
  NXgeometry
  integral_log:NXlog
\end{verbatim}

\begin{itemize}

\item{MONITOR:NXmonitor $\rightarrow$\\
\verb|  |\_NXmonitor.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXmonitor.NX\_id            MONITOR\\
\verb|  |\_NXmonitor.NX\_scan\_id      SCANID \\
\verb|  |\_NXmonitor.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXmonitor.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXmonitor\_\_MONITOR''
where MONITOR is the name of this group, typically ``monitor''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |count\_time:NX\_FLOAT=COUNT\_TIME $\rightarrow$\\
\verb|  |\_NXmonitor.count\_time COUNT\_TIME}

\item{\verb|  |data:NX\_NUMBER[n]=DATA $\rightarrow$\\
\verb|  |\_NXmonitor.data DATA}

\item{\verb|    |@signal=SIGNAL $\rightarrow$\\
\verb|    |\_NXmonitor.data\_\_signal SIGNAL}

\item{\verb|    |@axes=AXES $\rightarrow$\\
\verb|    |\_NXmonitor.data\_\_axes AXES}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXmonitor.distance DISTANCE}

\item{\verb|  |efficiency:NX\_NUMBER[]=EFFICIENCY $\rightarrow$\\
\verb|  |\_NXmonitor.efficiency EFFICIENCY}

\item{\verb|  |end\_time:NX\_DATE\_TIME=END\_TIME $\rightarrow$\\
\verb|  |\_NXmonitor.end\_time END\_TIME}

\item{\verb|  |integral:NX\_NUMBER=INTEGRAL $\rightarrow$\\
\verb|  |\_NXmonitor.integral INTEGRAL}

\item{\verb|  |mode:NX\_CHAR=MODE $\rightarrow$\\
\verb|  |\_NXmonitor.mode MODE}

\item{\verb|  |preset:NX\_NUMBER=PRESET $\rightarrow$\\
\verb|  |\_NXmonitor.preset PRESET}

\item{\verb|  |range:NX\_FLOAT[2]=RANGE $\rightarrow$\\
\verb|  |\_NXmonitor.range RANGE}

\item{\verb|  |sampled\_fraction:NX\_FLOAT=SAMPLED\_FRACTION $\rightarrow$\\
\verb|  |\_NXmonitor.sampled\_fraction SAMPLED\_FRACTION}

\item{\verb|  |start\_time:NX\_DATE\_TIME=START\_TIME $\rightarrow$\\
\verb|  |\_NXmonitor.start\_time START\_TIME}

\item{\verb|  |time\_of\_flight:NX\_FLOAT[]=TIME\_OF\_FLIGHT $\rightarrow$\\
\verb|  |\_NXmonitor.time\_of\_flight TIME\_OF\_FLIGHT}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXmonitor.type TYPE}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXmonitor.NXgeometry\_id geometry1}

\item{integral\_log:NXlog $\rightarrow$\\
\verb|  |\_NXmonitor.NXlog\_id integral\_log}
\end{itemize}
\subsection{NXmonochromator}

\begin{verbatim}
NXmonochromator (base class, version 1.0)
  energy:NX_FLOAT
  energy_error:NX_FLOAT
  wavelength:NX_FLOAT
  wavelength_error:NX_FLOAT
  NXcrystal
  distribution:NXdata
  geometry:NXgeometry
  NXvelocity_selector
\end{verbatim}

\begin{itemize}

\item{MONOCHROMATOR:NXmonochromator $\rightarrow$\\
\verb|  |\_NXmonochromator.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXmonochromator.NX\_id            MONOCHROMATOR\\
\verb|  |\_NXmonochromator.NX\_scan\_id      SCANID \\
\verb|  |\_NXmonochromator.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXmonochromator.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXmonochromator\_\_MONOCHROMATOR''
where MONOCHROMATOR is the name of this group, typically ``monochromator''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |energy:NX\_FLOAT=ENERGY $\rightarrow$\\
\verb|  |\_NXmonochromator.energy ENERGY}

\item{\verb|  |energy\_error:NX\_FLOAT=ENERGY\_ERROR $\rightarrow$\\
\verb|  |\_NXmonochromator.energy\_error ENERGY\_ERROR}

\item{\verb|  |wavelength:NX\_FLOAT=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXmonochromator.wavelength WAVELENGTH}

\item{\verb|  |wavelength\_error:NX\_FLOAT=WAVELENGTH\_ERROR $\rightarrow$\\
\verb|  |\_NXmonochromator.wavelength\_error WAVELENGTH\_ERROR}

\item{crystal1:NXcrystal $\rightarrow$\\
\verb|  |\_NXmonochromator.NXcrystal\_id crystal1}

\item{distribution:NXdata $\rightarrow$\\
\verb|  |\_NXmonochromator.NXdata\_id distribution}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXmonochromator.NXgeometry\_id geometry}

\item{velocity\_selector1:NXvelocity\_selector $\rightarrow$\\
\verb|  |\_NXmonochromator.NXvelocity\_selector\_id velocity\_selector1}
\end{itemize}
\subsection{NXnote}

\begin{verbatim}
NXnote (base class, version 1.0)
  author:NX_CHAR
  data:NX_BINARY
  date:NX_DATE_TIME
  description:NX_CHAR
  file_name:NX_CHAR
  type:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{NOTE:NXnote $\rightarrow$\\
\verb|  |\_NXnote.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXnote.NX\_id            NOTE\\
\verb|  |\_NXnote.NX\_scan\_id      SCANID \\
\verb|  |\_NXnote.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXnote.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXnote\_\_NOTE''
where NOTE is the name of this group, typically ``note''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |author:NX\_CHAR=AUTHOR $\rightarrow$\\
\verb|  |\_NXnote.author AUTHOR}

\item{\verb|  |data:NX\_BINARY=DATA $\rightarrow$\\
\verb|  |\_NXnote.data DATA}

\item{\verb|  |date:NX\_DATE\_TIME=DATE $\rightarrow$\\
\verb|  |\_NXnote.date DATE}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXnote.description DESCRIPTION}

\item{\verb|  |file\_name:NX\_CHAR=FILE\_NAME $\rightarrow$\\
\verb|  |\_NXnote.file\_name FILE\_NAME}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXnote.type TYPE}
\end{itemize}
\subsection{NXorientation}

\begin{verbatim}
NXorientation (base class, version 1.0)
  value:NX_FLOAT[numobj,6]
  NXgeometry
\end{verbatim}

\begin{itemize}

\item{ORIENTATION:NXorientation $\rightarrow$\\
\verb|  |\_NXorientation.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXorientation.NX\_id            ORIENTATION\\
\verb|  |\_NXorientation.NX\_scan\_id      SCANID \\
\verb|  |\_NXorientation.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXorientation.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXorientation\_\_ORIENTATION''
where ORIENTATION is the name of this group, typically ``orientation''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |value:NX\_FLOAT[numobj,6]=VALUE $\rightarrow$\\
\verb|  |\_NXorientation.value VALUE}

\item{geometry1:NXgeometry $\rightarrow$\\
\verb|  |\_NXorientation.NXgeometry\_id geometry1}
\end{itemize}
\subsection{NXparameters}

\begin{verbatim}
NXparameters (base class, version 1.0)
  term:NX_CHAR
    @units
\end{verbatim}

\begin{itemize}

\item{PARAMETERS:NXparameters $\rightarrow$\\
\verb|  |\_NXparameters.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXparameters.NX\_id            PARAMETERS\\
\verb|  |\_NXparameters.NX\_scan\_id      SCANID \\
\verb|  |\_NXparameters.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXparameters.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXparameters\_\_PARAMETERS''
where PARAMETERS is the name of this group, typically ``parameters''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |term:NX\_CHAR=TERM $\rightarrow$\\
\verb|  |\_NXparameters.term TERM}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXparameters.term\_\_units UNITS}
\end{itemize}
\subsection{NXpolarizer}

\begin{verbatim}
NXpolarizer (base class, version 1.0)
  composition:NX_CHAR
  efficiency:NX_FLOAT
  reflection:NX_INT[3]
  type:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{POLARIZER:NXpolarizer $\rightarrow$\\
\verb|  |\_NXpolarizer.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXpolarizer.NX\_id            POLARIZER\\
\verb|  |\_NXpolarizer.NX\_scan\_id      SCANID \\
\verb|  |\_NXpolarizer.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXpolarizer.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXpolarizer\_\_POLARIZER''
where POLARIZER is the name of this group, typically ``polarizer''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |composition:NX\_CHAR=COMPOSITION $\rightarrow$\\
\verb|  |\_NXpolarizer.composition COMPOSITION}

\item{\verb|  |efficiency:NX\_FLOAT=EFFICIENCY $\rightarrow$\\
\verb|  |\_NXpolarizer.efficiency EFFICIENCY}

\item{\verb|  |reflection:NX\_INT[3]=REFLECTION $\rightarrow$\\
\verb|  |\_NXpolarizer.reflection REFLECTION}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXpolarizer.type TYPE}
\end{itemize}
\subsection{NXpositioner}

\begin{verbatim}
NXpositioner (base class, version 1.0)
  acceleration_time:NX_NUMBER
  controller_record:NX_CHAR
  description:NX_CHAR
  name:NX_CHAR
  raw_value:NX_NUMBER[n]
  soft_limit_max:NX_NUMBER
  soft_limit_min:NX_NUMBER
  target_value:NX_NUMBER[n]
  tolerance:NX_NUMBER[n]
  value:NX_NUMBER[n]
  velocity:NX_NUMBER
\end{verbatim}

\begin{itemize}

\item{POSITIONER:NXpositioner $\rightarrow$\\
\verb|  |\_NXpositioner.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXpositioner.NX\_id            POSITIONER\\
\verb|  |\_NXpositioner.NX\_scan\_id      SCANID \\
\verb|  |\_NXpositioner.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXpositioner.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXpositioner\_\_POSITIONER''
where POSITIONER is the name of this group, typically ``positioner''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |acceleration\_time:NX\_NUMBER=ACCELERATION\_TIME $\rightarrow$\\
\verb|  |\_NXpositioner.acceleration\_time ACCELERATION\_TIME}

\item{\verb|  |controller\_record:NX\_CHAR=CONTROLLER\_RECORD $\rightarrow$\\
\verb|  |\_NXpositioner.controller\_record CONTROLLER\_RECORD}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXpositioner.description DESCRIPTION}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXpositioner.name NAME}

\item{\verb|  |raw\_value:NX\_NUMBER[n]=RAW\_VALUE $\rightarrow$\\
\verb|  |\_NXpositioner.raw\_value RAW\_VALUE}

\item{\verb|  |soft\_limit\_max:NX\_NUMBER=SOFT\_LIMIT\_MAX $\rightarrow$\\
\verb|  |\_NXpositioner.soft\_limit\_max SOFT\_LIMIT\_MAX}

\item{\verb|  |soft\_limit\_min:NX\_NUMBER=SOFT\_LIMIT\_MIN $\rightarrow$\\
\verb|  |\_NXpositioner.soft\_limit\_min SOFT\_LIMIT\_MIN}

\item{\verb|  |target\_value:NX\_NUMBER[n]=TARGET\_VALUE $\rightarrow$\\
\verb|  |\_NXpositioner.target\_value TARGET\_VALUE}

\item{\verb|  |tolerance:NX\_NUMBER[n]=TOLERANCE $\rightarrow$\\
\verb|  |\_NXpositioner.tolerance TOLERANCE}

\item{\verb|  |value:NX\_NUMBER[n]=VALUE $\rightarrow$\\
\verb|  |\_NXpositioner.value VALUE}

\item{\verb|  |velocity:NX\_NUMBER=VELOCITY $\rightarrow$\\
\verb|  |\_NXpositioner.velocity VELOCITY}
\end{itemize}
\subsection{NXprocess}

\begin{verbatim}
NXprocess (base class, version 1.0)
  date:NX_DATE_TIME
  program:NX_CHAR
  version:NX_CHAR
  NXnote
\end{verbatim}

\begin{itemize}

\item{PROCESS:NXprocess $\rightarrow$\\
\verb|  |\_NXprocess.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXprocess.NX\_id            PROCESS\\
\verb|  |\_NXprocess.NX\_scan\_id      SCANID \\
\verb|  |\_NXprocess.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXprocess.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXprocess\_\_PROCESS''
where PROCESS is the name of this group, typically ``process''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |date:NX\_DATE\_TIME=DATE $\rightarrow$\\
\verb|  |\_NXprocess.date DATE}

\item{\verb|  |program:NX\_CHAR=PROGRAM $\rightarrow$\\
\verb|  |\_NXprocess.program PROGRAM}

\item{\verb|  |version:NX\_CHAR=VERSION $\rightarrow$\\
\verb|  |\_NXprocess.version VERSION}

\item{note1:NXnote $\rightarrow$\\
\verb|  |\_NXprocess.NXnote\_id note1}
\end{itemize}
\subsection{NXroot}

\begin{verbatim}
NXroot (base class, version 1.0)
  @NX_class
  @file_time
  @file_name
  @file_update_time
  @NeXus_version
  @HDF_version
  @HDF5_Version
  @XML_version
  @creator
  NXentry
\end{verbatim}

\begin{itemize}

\item{ROOT:NXroot $\rightarrow$\\
\verb|  |\_NXroot.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXroot.NX\_id            ROOT\\
\verb|  |\_NXroot.NX\_scan\_id      SCANID \\
\verb|  |\_NXroot.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXroot.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the group, ending with ``/NXroot\_\_ROOT''
where ROOT is the name of this group, typically ``root''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |@NX\_class=NX\_CLASS $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_NX\_class NX\_CLASS}

\item{\verb|  |@file\_time=FILE\_TIME $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_file\_time FILE\_TIME}

\item{\verb|  |@file\_name=FILE\_NAME $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_file\_name FILE\_NAME}

\item{\verb|  |@file\_update\_time=FILE\_UPDATE\_TIME $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_file\_update\_time FILE\_UPDATE\_TIME}

\item{\verb|  |@NeXus\_version=NEXUS\_VERSION $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_NeXus\_version NEXUS\_VERSION}

\item{\verb|  |@HDF\_version=HDF\_VERSION $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_HDF\_version HDF\_VERSION}

\item{\verb|  |@HDF5\_Version=HDF5\_VERSION $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_HDF5\_Version HDF5\_VERSION}

\item{\verb|  |@XML\_version=XML\_VERSION $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_XML\_version XML\_VERSION}

\item{\verb|  |@creator=CREATOR $\rightarrow$\\
\verb|    |\_NXroot.NX\_class\_attribute\_\_creator CREATOR}

\item{entry1:NXentry $\rightarrow$\\
\verb|  |\_NXroot.NXentry\_id entry1}
\end{itemize}
\subsection{NXsample}

\begin{verbatim}
NXsample (base class, version 1.0)
  changer_position:NX_INT
  chemical_formula:NX_CHAR
  component:NX_CHAR
  concentration:NX_FLOAT[n_comp]
  density:NX_FLOAT[n_comp]
  description:NX_CHAR
  distance:NX_FLOAT
  electric_field:NX_FLOAT[n_eField]
    @direction
  external_DAC:NX_FLOAT
  magnetic_field:NX_FLOAT[n_mField]
    @direction
  mass:NX_FLOAT[n_comp]
  name:NX_CHAR
  orientation_matrix:NX_FLOAT[n_comp,3,3]
  path_length:NX_FLOAT
  path_length_window:NX_FLOAT
  preparation_date:NX_DATE_TIME
  pressure:NX_FLOAT[n_pField]
  relative_molecular_mass:NX_FLOAT[n_comp]
  rotation_angle:NX_FLOAT
  sample_component:NX_CHAR
  sample_orientation:NX_FLOAT[3]
  scattering_length_density:NX_FLOAT[n_comp]
  short_title:NX_CHAR
  situation:NX_CHAR
  stress_field:NX_FLOAT[n_sField]
    @direction
  temperature:NX_FLOAT[n_Temp]
  thickness:NX_FLOAT
  type:NX_CHAR
  unit_cell:NX_FLOAT[n_comp,6]
  unit_cell_class:NX_CHAR
  unit_cell_group:NX_CHAR
  unit_cell_volume:NX_FLOAT[n_comp]
  volume_fraction:NX_FLOAT[n_comp]
  x_translation:NX_FLOAT
  NXbeam
  transmission:NXdata
  temperature_env:NXenvironment
  magnetic_field_env:NXenvironment
  geometry:NXgeometry
  temperature_log:NXlog
  magnetic_field_log:NXlog
  external_ADC:NXlog
\end{verbatim}

\begin{itemize}

\item{SAMPLE:NXsample $\rightarrow$\\
\verb|  |\_NXsample.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXsample.NX\_id            SAMPLE\\
\verb|  |\_NXsample.NX\_scan\_id      SCANID \\
\verb|  |\_NXsample.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXsample.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXsample\_\_SAMPLE''
where SAMPLE is the name of this NeXus class instance, typically ``sample''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |changer\_position:NX\_INT=CHANGER\_POSITION $\rightarrow$\\
\verb|  |\_NXsample.changer\_position CHANGER\_POSITION}

\item{\verb|  |chemical\_formula:NX\_CHAR=CHEMICAL\_FORMULA $\rightarrow$\\
\verb|  |\_NXsample.chemical\_formula CHEMICAL\_FORMULA}

\item{\verb|  |component:NX\_CHAR=COMPONENT $\rightarrow$\\
\verb|  |\_NXsample.component COMPONENT}

\item{\verb|  |concentration:NX\_FLOAT[n\_comp]=CONCENTRATION $\rightarrow$\\
\verb|  |\_NXsample.concentration CONCENTRATION}

\item{\verb|  |density:NX\_FLOAT[n\_comp]=DENSITY $\rightarrow$\\
\verb|  |\_NXsample.density DENSITY}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXsample.description DESCRIPTION}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXsample.distance DISTANCE}

\item{\verb|  |electric\_field:NX\_FLOAT[n\_eField]=ELECTRIC\_FIELD $\rightarrow$\\
\verb|  |\_NXsample.electric\_field ELECTRIC\_FIELD}

\item{\verb|    |@direction=DIRECTION $\rightarrow$\\
\verb|    |\_NXsample.electric\_field\_\_direction DIRECTION}

\item{\verb|  |external\_DAC:NX\_FLOAT=EXTERNAL\_DAC $\rightarrow$\\
\verb|  |\_NXsample.external\_DAC EXTERNAL\_DAC}

\item{\verb|  |magnetic\_field:NX\_FLOAT[n\_mField]=MAGNETIC\_FIELD $\rightarrow$\\
\verb|  |\_NXsample.magnetic\_field MAGNETIC\_FIELD}

\item{\verb|    |@direction=DIRECTION $\rightarrow$\\
\verb|    |\_NXsample.magnetic\_field\_\_direction DIRECTION}

\item{\verb|  |mass:NX\_FLOAT[n\_comp]=MASS $\rightarrow$\\
\verb|  |\_NXsample.mass MASS}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXsample.name NAME}

\item{\verb|  |orientation\_matrix:NX\_FLOAT[n\_comp,3,3]=ORIENTATION\_MATRIX $\rightarrow$\\
\verb|  |\_NXsample.orientation\_matrix ORIENTATION\_MATRIX}

\item{\verb|  |path\_length:NX\_FLOAT=PATH\_LENGTH $\rightarrow$\\
\verb|  |\_NXsample.path\_length PATH\_LENGTH}

\item{\verb|  |path\_length\_window:NX\_FLOAT=PATH\_LENGTH\_WINDOW $\rightarrow$\\
\verb|  |\_NXsample.path\_length\_window PATH\_LENGTH\_WINDOW}

\item{\verb|  |preparation\_date:NX\_DATE\_TIME=PREPARATION\_DATE $\rightarrow$\\
\verb|  |\_NXsample.preparation\_date PREPARATION\_DATE}

\item{\verb|  |pressure:NX\_FLOAT[n\_pField]=PRESSURE $\rightarrow$\\
\verb|  |\_NXsample.pressure PRESSURE}

\item{\verb|  |relative\_molecular\_mass:NX\_FLOAT[n\_comp]=RELATIVE\_MOLECULAR\_MASS $\rightarrow$\\
\verb|  |\_NXsample.relative\_molecular\_mass RELATIVE\_MOLECULAR\_MASS}

\item{\verb|  |rotation\_angle:NX\_FLOAT=ROTATION\_ANGLE $\rightarrow$\\
\verb|  |\_NXsample.rotation\_angle ROTATION\_ANGLE}

\item{\verb|  |sample\_component:NX\_CHAR=SAMPLE\_COMPONENT $\rightarrow$\\
\verb|  |\_NXsample.sample\_component SAMPLE\_COMPONENT}

\item{\verb|  |sample\_orientation:NX\_FLOAT[3]=SAMPLE\_ORIENTATION $\rightarrow$\\
\verb|  |\_NXsample.sample\_orientation SAMPLE\_ORIENTATION}

\item{\verb|  |scattering\_length\_density:NX\_FLOAT[n\_comp]=SCATTERING\_LENGTH\_DENSITY $\rightarrow$\\
\verb|  |\_NXsample.scattering\_length\_density SCATTERING\_LENGTH\_DENSITY}

\item{\verb|  |short\_title:NX\_CHAR=SHORT\_TITLE $\rightarrow$\\
\verb|  |\_NXsample.short\_title SHORT\_TITLE}

\item{\verb|  |situation:NX\_CHAR=SITUATION $\rightarrow$\\
\verb|  |\_NXsample.situation SITUATION}

\item{\verb|  |stress\_field:NX\_FLOAT[n\_sField]=STRESS\_FIELD $\rightarrow$\\
\verb|  |\_NXsample.stress\_field STRESS\_FIELD}

\item{\verb|    |@direction=DIRECTION $\rightarrow$\\
\verb|    |\_NXsample.stress\_field\_\_direction DIRECTION}

\item{\verb|  |temperature:NX\_FLOAT[n\_Temp]=TEMPERATURE $\rightarrow$\\
\verb|  |\_NXsample.temperature TEMPERATURE}

\item{\verb|  |thickness:NX\_FLOAT=THICKNESS $\rightarrow$\\
\verb|  |\_NXsample.thickness THICKNESS}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXsample.type TYPE}

\item{\verb|  |unit\_cell:NX\_FLOAT[n\_comp,6]=UNIT\_CELL $\rightarrow$\\
\verb|  |\_NXsample.unit\_cell UNIT\_CELL}

\item{\verb|  |unit\_cell\_class:NX\_CHAR=UNIT\_CELL\_CLASS $\rightarrow$\\
\verb|  |\_NXsample.unit\_cell\_class UNIT\_CELL\_CLASS}

\item{\verb|  |unit\_cell\_group:NX\_CHAR=UNIT\_CELL\_GROUP $\rightarrow$\\
\verb|  |\_NXsample.unit\_cell\_group UNIT\_CELL\_GROUP}

\item{\verb|  |unit\_cell\_volume:NX\_FLOAT[n\_comp]=UNIT\_CELL\_VOLUME $\rightarrow$\\
\verb|  |\_NXsample.unit\_cell\_volume UNIT\_CELL\_VOLUME}

\item{\verb|  |volume\_fraction:NX\_FLOAT[n\_comp]=VOLUME\_FRACTION $\rightarrow$\\
\verb|  |\_NXsample.volume\_fraction VOLUME\_FRACTION}

\item{\verb|  |x\_translation:NX\_FLOAT=X\_TRANSLATION $\rightarrow$\\
\verb|  |\_NXsample.x\_translation X\_TRANSLATION}

\item{beam1:NXbeam $\rightarrow$\\
\verb|  |\_NXsample.NXbeam\_id beam1}

\item{transmission:NXdata $\rightarrow$\\
\verb|  |\_NXsample.NXdata\_id transmission}

\item{temperature\_env:NXenvironment $\rightarrow$\\
\verb|  |\_NXsample.NXenvironment\_id temperature\_env}

\item{magnetic\_field\_env:NXenvironment $\rightarrow$\\
\verb|  |\_NXsample.NXenvironment\_id magnetic\_field\_env}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXsample.NXgeometry\_id geometry}

\item{temperature\_log:NXlog $\rightarrow$\\
\verb|  |\_NXsample.NXlog\_id temperature\_log}

\item{magnetic\_field\_log:NXlog $\rightarrow$\\
\verb|  |\_NXsample.NXlog\_id magnetic\_field\_log}

\item{external\_ADC:NXlog $\rightarrow$\\
\verb|  |\_NXsample.NXlog\_id external\_ADC}
\end{itemize}
\subsection{NXsensor}

\begin{verbatim}
NXsensor (base class, version 1.0)
  attached_to:NX_CHAR
  external_field_brief:NX_CHAR
  high_trip_value:NX_FLOAT
  low_trip_value:NX_FLOAT
  measurement:NX_CHAR
  model:NX_CHAR
  name:NX_CHAR
  run_control:NX_BOOLEAN
  short_name:NX_CHAR
  type:NX_CHAR
  value:NX_FLOAT[n]
  value_deriv1:NX_FLOAT[]
  value_deriv2:NX_FLOAT[]
  geometry:NXgeometry
  value_log:NXlog
  value_deriv1_log:NXlog
  value_deriv2_log:NXlog
  external_field_full:NXorientation
\end{verbatim}

\begin{itemize}

\item{SENSOR:NXsensor $\rightarrow$\\
\verb|  |\_NXsensor.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXsensor.NX\_id            SENSOR\\
\verb|  |\_NXsensor.NX\_scan\_id      SCANID \\
\verb|  |\_NXsensor.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXsensor.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXsensor\_\_SENSOR''
where SENSOR is the name of this NeXus class instance, typically ``sensor''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |attached\_to:NX\_CHAR=ATTACHED\_TO $\rightarrow$\\
\verb|  |\_NXsensor.attached\_to ATTACHED\_TO}

\item{\verb|  |external\_field\_brief:NX\_CHAR=EXTERNAL\_FIELD\_BRIEF $\rightarrow$\\
\verb|  |\_NXsensor.external\_field\_brief EXTERNAL\_FIELD\_BRIEF}

\item{\verb|  |high\_trip\_value:NX\_FLOAT=HIGH\_TRIP\_VALUE $\rightarrow$\\
\verb|  |\_NXsensor.high\_trip\_value HIGH\_TRIP\_VALUE}

\item{\verb|  |low\_trip\_value:NX\_FLOAT=LOW\_TRIP\_VALUE $\rightarrow$\\
\verb|  |\_NXsensor.low\_trip\_value LOW\_TRIP\_VALUE}

\item{\verb|  |measurement:NX\_CHAR=MEASUREMENT $\rightarrow$\\
\verb|  |\_NXsensor.measurement MEASUREMENT}

\item{\verb|  |model:NX\_CHAR=MODEL $\rightarrow$\\
\verb|  |\_NXsensor.model MODEL}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXsensor.name NAME}

\item{\verb|  |run\_control:NX\_BOOLEAN=RUN\_CONTROL $\rightarrow$\\
\verb|  |\_NXsensor.run\_control RUN\_CONTROL}

\item{\verb|  |short\_name:NX\_CHAR=SHORT\_NAME $\rightarrow$\\
\verb|  |\_NXsensor.short\_name SHORT\_NAME}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXsensor.type TYPE}

\item{\verb|  |value:NX\_FLOAT[n]=VALUE $\rightarrow$\\
\verb|  |\_NXsensor.value VALUE}

\item{\verb|  |value\_deriv1:NX\_FLOAT[]=VALUE\_DERIV1 $\rightarrow$\\
\verb|  |\_NXsensor.value\_deriv1 VALUE\_DERIV1}

\item{\verb|  |value\_deriv2:NX\_FLOAT[]=VALUE\_DERIV2 $\rightarrow$\\
\verb|  |\_NXsensor.value\_deriv2 VALUE\_DERIV2}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXsensor.NXgeometry\_id geometry}

\item{value\_log:NXlog $\rightarrow$\\
\verb|  |\_NXsensor.NXlog\_id value\_log}

\item{value\_deriv1\_log:NXlog $\rightarrow$\\
\verb|  |\_NXsensor.NXlog\_id value\_deriv1\_log}

\item{value\_deriv2\_log:NXlog $\rightarrow$\\
\verb|  |\_NXsensor.NXlog\_id value\_deriv2\_log}

\item{external\_field\_full:NXorientation $\rightarrow$\\
\verb|  |\_NXsensor.NXorientation\_id external\_field\_full}
\end{itemize}
\subsection{NXshape}

\begin{verbatim}
NXshape (base class, version 1.0)
  direction:NX_CHAR
  shape:NX_CHAR
  size:NX_FLOAT[numobj,nshapepar]
\end{verbatim}

\begin{itemize}

\item{SHAPE:NXshape $\rightarrow$\\
\verb|  |\_NXshape.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXshape.NX\_id            SHAPE\\
\verb|  |\_NXshape.NX\_scan\_id      SCANID \\
\verb|  |\_NXshape.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXshape.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXshape\_\_SHAPE''
where SHAPE is the name of this NeXus class instance, typically ``shape''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |direction:NX\_CHAR=DIRECTION $\rightarrow$\\
\verb|  |\_NXshape.direction DIRECTION}

\item{\verb|  |shape:NX\_CHAR=SHAPE $\rightarrow$\\
\verb|  |\_NXshape.shape SHAPE}

\item{\verb|  |size:NX\_FLOAT[numobj,nshapepar]=SIZE $\rightarrow$\\
\verb|  |\_NXshape.size SIZE}
\end{itemize}
\subsection{NXsource}

\begin{verbatim}
NXsource (base class, version 1.0)
  bunch_distance:NX_FLOAT
  bunch_length:NX_FLOAT
  current:NX_FLOAT
  distance:NX_FLOAT
  emittance_x:NX_FLOAT
  emittance_y:NX_FLOAT
  energy:NX_FLOAT
  flux:NX_FLOAT
  frequency:NX_FLOAT
  last_fill:NX_NUMBER
    @time
  mode:NX_CHAR
  name:NX_CHAR
    @short_name
  number_of_bunches:NX_INT
  period:NX_FLOAT
  power:NX_FLOAT
  probe:NX_CHAR
  pulse_width:NX_FLOAT
  sigma_x:NX_FLOAT
  sigma_y:NX_FLOAT
  target_material:NX_CHAR
  top_up:NX_BOOLEAN
  type:NX_CHAR
  voltage:NX_FLOAT
  bunch_pattern:NXdata
    title:NX_CHAR
  pulse_shape:NXdata
  distribution:NXdata
  geometry:NXgeometry
  notes:NXnote
\end{verbatim}

\begin{itemize}

\item{SOURCE:NXsource $\rightarrow$\\
\verb|  |\_NXsource.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXsource.NX\_id            SOURCE\\
\verb|  |\_NXsource.NX\_scan\_id      SCANID \\
\verb|  |\_NXsource.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXsource.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXsource\_\_SOURCE''
where SOURCE is the name of this NeXus class instance, typically ``source''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |bunch\_distance:NX\_FLOAT=BUNCH\_DISTANCE $\rightarrow$\\
\verb|  |\_NXsource.bunch\_distance BUNCH\_DISTANCE}

\item{\verb|  |bunch\_length:NX\_FLOAT=BUNCH\_LENGTH $\rightarrow$\\
\verb|  |\_NXsource.bunch\_length BUNCH\_LENGTH}

\item{\verb|  |current:NX\_FLOAT=CURRENT $\rightarrow$\\
\verb|  |\_NXsource.current CURRENT}

\item{\verb|  |distance:NX\_FLOAT=DISTANCE $\rightarrow$\\
\verb|  |\_NXsource.distance DISTANCE}

\item{\verb|  |emittance\_x:NX\_FLOAT=EMITTANCE\_X $\rightarrow$\\
\verb|  |\_NXsource.emittance\_x EMITTANCE\_X}

\item{\verb|  |emittance\_y:NX\_FLOAT=EMITTANCE\_Y $\rightarrow$\\
\verb|  |\_NXsource.emittance\_y EMITTANCE\_Y}

\item{\verb|  |energy:NX\_FLOAT=ENERGY $\rightarrow$\\
\verb|  |\_NXsource.energy ENERGY}

\item{\verb|  |flux:NX\_FLOAT=FLUX $\rightarrow$\\
\verb|  |\_NXsource.flux FLUX}

\item{\verb|  |frequency:NX\_FLOAT=FREQUENCY $\rightarrow$\\
\verb|  |\_NXsource.frequency FREQUENCY}

\item{\verb|  |last\_fill:NX\_NUMBER=LAST\_FILL $\rightarrow$\\
\verb|  |\_NXsource.last\_fill LAST\_FILL}

\item{\verb|    |@time=TIME $\rightarrow$\\
\verb|    |\_NXsource.last\_fill\_\_time TIME}

\item{\verb|  |mode:NX\_CHAR=MODE $\rightarrow$\\
\verb|  |\_NXsource.mode MODE}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXsource.name NAME}

\item{\verb|    |@short\_name=SHORT\_NAME $\rightarrow$\\
\verb|    |\_NXsource.name\_\_short\_name SHORT\_NAME}

\item{\verb|  |number\_of\_bunches:NX\_INT=NUMBER\_OF\_BUNCHES $\rightarrow$\\
\verb|  |\_NXsource.number\_of\_bunches NUMBER\_OF\_BUNCHES}

\item{\verb|  |period:NX\_FLOAT=PERIOD $\rightarrow$\\
\verb|  |\_NXsource.period PERIOD}

\item{\verb|  |power:NX\_FLOAT=POWER $\rightarrow$\\
\verb|  |\_NXsource.power POWER}

\item{\verb|  |probe:NX\_CHAR=PROBE $\rightarrow$\\
\verb|  |\_NXsource.probe PROBE}

\item{\verb|  |pulse\_width:NX\_FLOAT=PULSE\_WIDTH $\rightarrow$\\
\verb|  |\_NXsource.pulse\_width PULSE\_WIDTH}

\item{\verb|  |sigma\_x:NX\_FLOAT=SIGMA\_X $\rightarrow$\\
\verb|  |\_NXsource.sigma\_x SIGMA\_X}

\item{\verb|  |sigma\_y:NX\_FLOAT=SIGMA\_Y $\rightarrow$\\
\verb|  |\_NXsource.sigma\_y SIGMA\_Y}

\item{\verb|  |target\_material:NX\_CHAR=TARGET\_MATERIAL $\rightarrow$\\
\verb|  |\_NXsource.target\_material TARGET\_MATERIAL}

\item{\verb|  |top\_up:NX\_BOOLEAN=TOP\_UP $\rightarrow$\\
\verb|  |\_NXsource.top\_up TOP\_UP}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXsource.type TYPE}

\item{\verb|  |voltage:NX\_FLOAT=VOLTAGE $\rightarrow$\\
\verb|  |\_NXsource.voltage VOLTAGE}

\item{bunch\_pattern:NXdata $\rightarrow$\\
\verb|  |\_NXsource.NXdata\_id bunch\_pattern}

\item{\verb|    |title:NX\_CHAR=TITLE $\rightarrow$\\
\verb|  |\_NXsource.title TITLE}

\item{pulse\_shape:NXdata $\rightarrow$\\
\verb|  |\_NXsource.NXdata\_id pulse\_shape}

\item{distribution:NXdata $\rightarrow$\\
\verb|  |\_NXsource.NXdata\_id distribution}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXsource.NXgeometry\_id geometry}

\item{notes:NXnote $\rightarrow$\\
\verb|  |\_NXsource.NXnote\_id notes}
\end{itemize}
\subsection{NXsubentry}

\begin{verbatim}
NXsubentry (base class, version 1.0)
  @IDF_Version
  collection_description:NX_CHAR
  collection_identifier:NX_CHAR
  collection_time:NX_FLOAT
  definition:NX_CHAR
    @version
    @URL
  definition_local:NX_CHAR
    @version
    @URL
  duration:NX_INT
  end_time:NX_DATE_TIME
  entry_identifier:NX_CHAR
  experiment_description:NX_CHAR
  experiment_identifier:NX_CHAR
  pre_sample_flightpath:NX_FLOAT
  program_name:NX_CHAR
    @version
    @configuration
  revision:NX_CHAR
    @comment
  run_cycle:NX_CHAR
  start_time:NX_DATE_TIME
  title:NX_CHAR
  NXcharacterization
  NXdata
  NXinstrument
  NXmonitor
  experiment_documentation:NXnote
  notes:NXnote
  thumbnail:NXnote
    @mime_type
  NXprocess
  NXsample
  NXuser
\end{verbatim}

\begin{itemize}

\item{SUBENTRY:NXsubentry $\rightarrow$\\
\verb|  |\_NXsubentry.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXsubentry.NX\_id            SUBENTRY \\
\verb|  |\_NXsubentry.NX\_scan\_id      SCANID \\
\verb|  |\_NXsubentry.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXsubentry.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXsubentry\_\_SUBENTRY''
where SUBENTRY is the name of this NeXus class instance, typically ``subentry''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |@IDF\_Version=IDF\_VERSION $\rightarrow$\\
\verb|    |\_NXsubentry.NX\_class\_attribute\_\_IDF\_Version IDF\_VERSION}

\item{\verb|  |collection\_description:NX\_CHAR=COLLECTION\_DESCRIPTION $\rightarrow$\\
\verb|  |\_NXsubentry.collection\_description COLLECTION\_DESCRIPTION}

\item{\verb|  |collection\_identifier:NX\_CHAR=COLLECTION\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXsubentry.collection\_identifier COLLECTION\_IDENTIFIER}

\item{\verb|  |collection\_time:NX\_FLOAT=COLLECTION\_TIME $\rightarrow$\\
\verb|  |\_NXsubentry.collection\_time COLLECTION\_TIME}

\item{\verb|  |definition:NX\_CHAR=DEFINITION $\rightarrow$\\
\verb|  |\_NXsubentry.definition DEFINITION}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXsubentry.definition\_\_version VERSION}

\item{\verb|    |@URL=URL $\rightarrow$\\
\verb|    |\_NXsubentry.definition\_\_URL URL}

\item{\verb|  |definition\_local:NX\_CHAR=DEFINITION\_LOCAL $\rightarrow$\\
\verb|  |\_NXsubentry.definition\_local DEFINITION\_LOCAL}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXsubentry.definition\_local\_\_version VERSION}

\item{\verb|    |@URL=URL $\rightarrow$\\
\verb|    |\_NXsubentry.definition\_local\_\_URL URL}

\item{\verb|  |duration:NX\_INT=DURATION $\rightarrow$\\
\verb|  |\_NXsubentry.duration DURATION}

\item{\verb|  |end\_time:NX\_DATE\_TIME=END\_TIME $\rightarrow$\\
\verb|  |\_NXsubentry.end\_time END\_TIME}

\item{\verb|  |entry\_identifier:NX\_CHAR=ENTRY\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXsubentry.entry\_identifier ENTRY\_IDENTIFIER}

\item{\verb|  |experiment\_description:NX\_CHAR=EXPERIMENT\_DESCRIPTION $\rightarrow$\\
\verb|  |\_NXsubentry.experiment\_description EXPERIMENT\_DESCRIPTION}

\item{\verb|  |experiment\_identifier:NX\_CHAR=EXPERIMENT\_IDENTIFIER $\rightarrow$\\
\verb|  |\_NXsubentry.experiment\_identifier EXPERIMENT\_IDENTIFIER}

\item{\verb|  |pre\_sample\_flightpath:NX\_FLOAT=PRE\_SAMPLE\_FLIGHTPATH $\rightarrow$\\
\verb|  |\_NXsubentry.pre\_sample\_flightpath PRE\_SAMPLE\_FLIGHTPATH}

\item{\verb|  |program\_name:NX\_CHAR=PROGRAM\_NAME $\rightarrow$\\
\verb|  |\_NXsubentry.program\_name PROGRAM\_NAME}

\item{\verb|    |@version=VERSION $\rightarrow$\\
\verb|    |\_NXsubentry.program\_name\_\_version VERSION}

\item{\verb|    |@configuration=CONFIGURATION $\rightarrow$\\
\verb|    |\_NXsubentry.program\_name\_\_configuration CONFIGURATION}

\item{\verb|  |revision:NX\_CHAR=REVISION $\rightarrow$\\
\verb|  |\_NXsubentry.revision REVISION}

\item{\verb|    |@comment=COMMENT $\rightarrow$\\
\verb|    |\_NXsubentry.revision\_\_comment COMMENT}

\item{\verb|  |run\_cycle:NX\_CHAR=RUN\_CYCLE $\rightarrow$\\
\verb|  |\_NXsubentry.run\_cycle RUN\_CYCLE}

\item{\verb|  |start\_time:NX\_DATE\_TIME=START\_TIME $\rightarrow$\\
\verb|  |\_NXsubentry.start\_time START\_TIME}

\item{\verb|  |title:NX\_CHAR=TITLE $\rightarrow$\\
\verb|  |\_NXsubentry.title TITLE}

\item{characterization1:NXcharacterization $\rightarrow$\\
\verb|  |\_NXsubentry.NXcharacterization\_id characterization1}

\item{data1:NXdata $\rightarrow$\\
\verb|  |\_NXsubentry.NXdata\_id data1}

\item{instrument1:NXinstrument $\rightarrow$\\
\verb|  |\_NXsubentry.NXinstrument\_id instrument1}

\item{monitor1:NXmonitor $\rightarrow$\\
\verb|  |\_NXsubentry.NXmonitor\_id monitor1}

\item{experiment\_documentation:NXnote $\rightarrow$\\
\verb|  |\_NXsubentry.NXnote\_id experiment\_documentation}

\item{notes:NXnote $\rightarrow$\\
\verb|  |\_NXsubentry.NXnote\_id notes}

\item{thumbnail:NXnote $\rightarrow$\\
\verb|  |\_NXsubentry.NXnote\_id thumbnail}

\item{\verb|    |@mime\_type=MIME\_TYPE $\rightarrow$\\
\verb|    |\_NXsubentry.title\_\_mime\_type MIME\_TYPE}

\item{process1:NXprocess $\rightarrow$\\
\verb|  |\_NXsubentry.NXprocess\_id process1}

\item{sample1:NXsample $\rightarrow$\\
\verb|  |\_NXsubentry.NXsample\_id sample1}

\item{user1:NXuser $\rightarrow$\\
\verb|  |\_NXsubentry.NXuser\_id user1}
\end{itemize}

\subsection{NXtransformations}

\begin{verbatim}
NXtransformations (base class, version 1.0)
  @default:NX_CHAR
  AXISNAME:
    @transformation_type: (optional) NX_CHAR
    @vector: (required) NX_NUMBER[3]
    @offset: (optional) NX_NUMBER[3]
    @offset_units: (optional) NX_CHAR
    @depends_on: (optional) NX_CHAR
    @equipment_component: (optional) NX_CHAR
  AXISNAME_end: (optional) NX_CHAR
  AXISNAME_increment_set:  (optional) NX_CHAR
\end{verbatim}

\begin{itemize}

\item{AXISNAME:NXtransformations $\rightarrow$\\
\verb|  |\_NXtransformations\_transformation\_type~~XFORMTYPE\\
\verb|  |\_NXtransformations\_vector~~~~~~~~~~~~~~~XFORMVECTOR\\
\verb|  |\_NXtransformations\_offset~~~~~~~~~~~~~~~XFORMOFFSET\\
\verb|  |\_NXtransformations\_offset\_units~~~~~~~~ XFORMOFFSTUN\\
\verb|  |\_NXtransformations\_depends\_on~~~~~~~~~~~XFORMDEPON\\
\verb|  |\_NXtransformations\_equipment\_component~~XFORMCOMPON\\
for which, in the CIF version, AXISNAME XFORMTYPE is mapped to
\_axis.id, XFORMVECTOR and XFORMOFFSET need to be converted
from NeXus McStas conventions to appropriate CBF/imgCIF conventions
and then mapped to \_axis.vector[1], \_axis.vector[2], and
\_axis.vector[3], and \_axis.offset[1], \_axis.offset[2], and
\_axis.offset[3], XFORMDEPON is mapped to \_axis.depends\_on, and
XFORMCOMPON is mapped to \_axis.equipment and \_axis.equipment\_component.
}
\end{itemize}


\subsection{NXtranslation}

\begin{verbatim}
NXtranslation (base class, version 1.0)
  distances:NX_FLOAT[numobj,3]
  geometry:NXgeometry
\end{verbatim}

\begin{itemize}

\item{TRANSLATION:NXtranslation $\rightarrow$\\
\verb|  |\_NXtranslation.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXtranslation.NX\_id            TRANSLATION \\
\verb|  |\_NXtranslation.NX\_scan\_id      SCANID \\
\verb|  |\_NXtranslation.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXtranslation.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXtranslation\_\_TRANSLATION''
where TRANSLATION is the name of this NeXus class instance, typically ``translation''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |distances:NX\_FLOAT[numobj,3]=DISTANCES $\rightarrow$\\
\verb|  |\_NXtranslation.distances DISTANCES}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXtranslation.NXgeometry\_id geometry}
\end{itemize}
\subsection{NXuser}

\begin{verbatim}
NXuser (base class, version 1.0)
  address:NX_CHAR
  affiliation:NX_CHAR
  email:NX_CHAR
  facility_user_id:NX_CHAR
  fax_number:NX_CHAR
  name:NX_CHAR
  role:NX_CHAR
  telephone_number:NX_CHAR
\end{verbatim}

\begin{itemize}

\item{USER:NXuser $\rightarrow$\\
\verb|  |\_NXuser.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXuser.NX\_id            USER \\
\verb|  |\_NXuser.NX\_scan\_id      SCANID \\
\verb|  |\_NXuser.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXuser.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXuser\_\_USER''
where USER is the name of this NeXus class instance, typically ``user''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |address:NX\_CHAR=ADDRESS $\rightarrow$\\
\verb|  |\_NXuser.address ADDRESS}

\item{\verb|  |affiliation:NX\_CHAR=AFFILIATION $\rightarrow$\\
\verb|  |\_NXuser.affiliation AFFILIATION}

\item{\verb|  |email:NX\_CHAR=EMAIL $\rightarrow$\\
\verb|  |\_NXuser.email EMAIL}

\item{\verb|  |facility\_user\_id:NX\_CHAR=FACILITY\_USER\_ID $\rightarrow$\\
\verb|  |\_NXuser.facility\_user\_id FACILITY\_USER\_ID}

\item{\verb|  |fax\_number:NX\_CHAR=FAX\_NUMBER $\rightarrow$\\
\verb|  |\_NXuser.fax\_number FAX\_NUMBER}

\item{\verb|  |name:NX\_CHAR=NAME $\rightarrow$\\
\verb|  |\_NXuser.name NAME}

\item{\verb|  |role:NX\_CHAR=ROLE $\rightarrow$\\
\verb|  |\_NXuser.role ROLE}

\item{\verb|  |telephone\_number:NX\_CHAR=TELEPHONE\_NUMBER $\rightarrow$\\
\verb|  |\_NXuser.telephone\_number TELEPHONE\_NUMBER}
\end{itemize}
\subsection{NXvelocity\_selector}

\begin{verbatim}
NXvelocity_selector (base class, version 1.0)
  height:NX_FLOAT
  length:NX_FLOAT
  num:NX_INT
  radius:NX_FLOAT
  rotation_speed:NX_FLOAT
  spwidth:NX_FLOAT
  table:NX_FLOAT
  twist:NX_FLOAT
  type:NX_CHAR
  wavelength:NX_FLOAT
  wavelength_spread:NX_FLOAT
  width:NX_FLOAT
  geometry:NXgeometry
\end{verbatim}

\begin{itemize}

\item{VELOCITY\_SELECTOR:NXvelocity\_selector $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXvelocity\_selector.NX\_id            VELOCITY\_SELECTOR \\
\verb|  |\_NXvelocity\_selector.NX\_scan\_id      SCANID \\
\verb|  |\_NXvelocity\_selector.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXvelocity\_selector.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXvelocity\_selector\_\_VELOCITY\_SELECTOR''
where VELOCITY\_SELECTOR is the name of this NeXus class instance, typically ``velocity\_selector''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |height:NX\_FLOAT=HEIGHT $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.height HEIGHT}

\item{\verb|  |length:NX\_FLOAT=LENGTH $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.length LENGTH}

\item{\verb|  |num:NX\_INT=NUM $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.num NUM}

\item{\verb|  |radius:NX\_FLOAT=RADIUS $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.radius RADIUS}

\item{\verb|  |rotation\_speed:NX\_FLOAT=ROTATION\_SPEED $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.rotation\_speed ROTATION\_SPEED}

\item{\verb|  |spwidth:NX\_FLOAT=SPWIDTH $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.spwidth SPWIDTH}

\item{\verb|  |table:NX\_FLOAT=TABLE $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.table TABLE}

\item{\verb|  |twist:NX\_FLOAT=TWIST $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.twist TWIST}

\item{\verb|  |type:NX\_CHAR=TYPE $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.type TYPE}

\item{\verb|  |wavelength:NX\_FLOAT=WAVELENGTH $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.wavelength WAVELENGTH}

\item{\verb|  |wavelength\_spread:NX\_FLOAT=WAVELENGTH\_SPREAD $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.wavelength\_spread WAVELENGTH\_SPREAD}

\item{\verb|  |width:NX\_FLOAT=WIDTH $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.width WIDTH}

\item{geometry:NXgeometry $\rightarrow$\\
\verb|  |\_NXvelocity\_selector.NXgeometry\_id geometry}
\end{itemize}
\subsection{NXxraylens}

\begin{verbatim}
NXxraylens (base class, version 1.0)
  aperture:NX_FLOAT
  curvature:NX_FLOAT
  cylindrical:NX_BOOLEAN
  focus_type:NX_CHAR
  gas:NX_CHAR
  gas_pressure:NX_FLOAT
  lens_geometry:NX_CHAR
  lens_length:NX_FLOAT
  lens_material:NX_CHAR
  lens_thickness:NX_FLOAT
  number_of_lenses:NX_INT
  symmetric:NX_BOOLEAN
  cylinder_orientation:NXnote
\end{verbatim}

\begin{itemize}

\item{XRAYLENS:NXxraylens $\rightarrow$\\
\verb|  |\_NXxraylens.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXxraylens.NX\_id            XRAYLENS \\
\verb|  |\_NXxraylens.NX\_scan\_id      SCANID \\
\verb|  |\_NXxraylens.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXxraylens.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXxraylens\_\_XRAYLENS''
where XRAYLENS is the name of this NeXus class instance, typically ``xraylens''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |aperture:NX\_FLOAT=APERTURE $\rightarrow$\\
\verb|  |\_NXxraylens.aperture APERTURE}

\item{\verb|  |curvature:NX\_FLOAT=CURVATURE $\rightarrow$\\
\verb|  |\_NXxraylens.curvature CURVATURE}

\item{\verb|  |cylindrical:NX\_BOOLEAN=CYLINDRICAL $\rightarrow$\\
\verb|  |\_NXxraylens.cylindrical CYLINDRICAL}

\item{\verb|  |focus\_type:NX\_CHAR=FOCUS\_TYPE $\rightarrow$\\
\verb|  |\_NXxraylens.focus\_type FOCUS\_TYPE}

\item{\verb|  |gas:NX\_CHAR=GAS $\rightarrow$\\
\verb|  |\_NXxraylens.gas GAS}

\item{\verb|  |gas\_pressure:NX\_FLOAT=GAS\_PRESSURE $\rightarrow$\\
\verb|  |\_NXxraylens.gas\_pressure GAS\_PRESSURE}

\item{\verb|  |lens\_geometry:NX\_CHAR=LENS\_GEOMETRY $\rightarrow$\\
\verb|  |\_NXxraylens.lens\_geometry LENS\_GEOMETRY}

\item{\verb|  |lens\_length:NX\_FLOAT=LENS\_LENGTH $\rightarrow$\\
\verb|  |\_NXxraylens.lens\_length LENS\_LENGTH}

\item{\verb|  |lens\_material:NX\_CHAR=LENS\_MATERIAL $\rightarrow$\\
\verb|  |\_NXxraylens.lens\_material LENS\_MATERIAL}

\item{\verb|  |lens\_thickness:NX\_FLOAT=LENS\_THICKNESS $\rightarrow$\\
\verb|  |\_NXxraylens.lens\_thickness LENS\_THICKNESS}

\item{\verb|  |number\_of\_lenses:NX\_INT=NUMBER\_OF\_LENSES $\rightarrow$\\
\verb|  |\_NXxraylens.number\_of\_lenses NUMBER\_OF\_LENSES}

\item{\verb|  |symmetric:NX\_BOOLEAN=SYMMETRIC $\rightarrow$\\
\verb|  |\_NXxraylens.symmetric SYMMETRIC}

\item{cylinder\_orientation:NXnote $\rightarrow$\\
\verb|  |\_NXxraylens.NXnote\_id cylinder\_orientation}
\end{itemize}

~~\\

~~\\

~~\\

~~\\

~~\\

\goodbreak



\section{Proposed Pixel Array Detector Application Definitions}
\label{Proposed Pixel Array Detector Application Definitions}

The following has been derived from the current Dectris Eiger test data and
presentations and the Dectris web site: 

\url{https://www.dectris.com/nexus.html#main_head_navigation}  

In this version we have noted the multi-NXDATA use of
NXentry, and note the extensions to NXdectector by including what
Dectris has called detectorSpecific:DetectorSpecific
detectorSpecific:DECTRIS\_dectector\_specific
as a recommended placeholders for such information in an
update to the NXdetector base class.   We have also called
detectorModule\_xxx:DetectorModule detectorModule\_xxx:DECTRIS\_dectector\_module
and detectorChip\_xxx:DetectorChip detectorChip\_xxx:DECTRIS\_detector\_chip.
These changes in class names have no impact on the relevant HDF5 paths.


\subsection{NXentry}

The base class NXentry currently has the following structure:

\begin{verbatim}
NXentry (base class, version 1.0)
  @IDF_Version
  collection_description:NX_CHAR
  collection_identifier:NX_CHAR
  collection_time:NX_FLOAT
  definition:NX_CHAR
    @version
    @URL
  definition_local:NX_CHAR
    @version
    @URL
  duration:NX_INT
  end_time:NX_DATE_TIME
  entry_identifier:NX_CHAR
  experiment_description:NX_CHAR
  experiment_identifier:NX_CHAR
  pre_sample_flightpath:NX_FLOAT
  program_name:NX_CHAR
    @version
    @configuration
  revision:NX_CHAR
    @comment
  run_cycle:NX_CHAR
  start_time:NX_DATE_TIME
  title:NX_CHAR
  NXcharacterization
  NXdata
  NXinstrument
  NXmonitor
  experiment_documentation:NXnote
  notes:NXnote
  thumbnail:NXnote
    @mime_type
  NXprocess
  NXsample
  NXsubentry
  NXuser
\end{verbatim}

There is no conflict between the Dectris proposal and this class.  We recommend
that NIAC formally adopt the use of multiple NXdata NeXus class instances
in NXentry and note that in the NXentry base class definition, not just imply that
possibility in the NXdata base class definition as is now the case, so that the
Detris proposal

\begin{verbatim}
NXentry_pad (application definition, version 0.1) (overlays NXentry)
  data_000001:NXDATA
  data_000002:NXDATA
  ...
  data_nnnnnn:NXDATA
  instrument:NXinstrument
  ...
\end{verbatim}

will not raise any questions.  The CIF mapping of the Dectris proposal
would then be:

\begin{itemize}

\item{ENTRY:NXentry $\rightarrow$\\
\verb|  |\_NXentry.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXentry.NX\_id            ENTRY \\
\verb|  |\_NXentry.NX\_scan\_id      SCANID \\
\verb|  |\_NXentry.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXentry.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXentry\_\_ENTRY''
where ENTRY is the name of this NeXus class instance, typically ``entry''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{data\_000001:NXDATA $\rightarrow$\\
\verb|  |\_NXentry.NXDATA\_id data\_000001}

\item{data\_000002:NXDATA $\rightarrow$\\
\verb|  |\_NXentry.NXDATA\_id data\_000002}
\\
~~...
\item{data\_nnnnnn:NXDATA $\rightarrow$\\
\verb|  |\_NXentry.NXDATA\_id data\_nnnnnn}

\item{instrument:NXinstrument $\rightarrow$\\
\verb|  |\_NXentry.NXinstrument\_id instrument}
\end{itemize}


\subsection{NXinstrument}

There is no conflict between the Dectris proposal and this class.  
The Dectris use is 


\begin{verbatim}
NXinstrument
  dectector:NXdetector
\end{verbatim}

which is a standard use and would map in CIF to 

\begin{itemize}

\item{INSTRUMENT:NXinstrument $\rightarrow$\\
\verb|  |\_NXinstrument.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXinstrument.NX\_id            INSTRUMENT \\
\verb|  |\_NXinstrument.NX\_scan\_id      SCANID \\
\verb|  |\_NXinstrument.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXinstrument.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with 
``/NXinstrument\_\_INSTRUMENT''
where INSTRUMENT is the name of this NeXus class instance, typically ``instrument''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{dectector:NXdetector $\rightarrow$\\
\verb|  |\_NXinstrument.NXdetector\_id dectector}
\end{itemize}


\subsection{NXdetector}

There are minor conflicts between the Dectris proposal and this class.
Dectris has used the detector\_number field as a character
string, rather than as a number.  We have added the
``Dectris\_'' prefix for the character string version and changes
the name to ``Dectris\_detector\_serial\_number''.
The use of character string serial ``numbers'' is a common
practice for electronic equipment, so we recommend that
a ``detector\_serial\_number:NX\_CHAR'' field be added
to the NXdetector base class to carry this information.
The field detector\_distance is not currently in this class.
We have added the ``Dectris\_'' prefix as a placeholder
until a field with this information is added to the
base class.  Mark Koennecke has suggested ``sample\_detector\_distance''
as the new field name, so the name used here is
``Dectris\_sample\_detector\_distance''

Dectris has added one subclass, which is likely to be
needed for almost all pixel array detectors.  However, at the
moment, what is proposed is a Dectris-specific class definition,
so rather than proposing the subclass immediately as a new NeXus 
base class, we propose the subclass with a ``DECTRIS\_'' prefix.
The revised NXdetector base class would then be as follows.
The fields explicitly used by DECTRIS are noted with [**].
Fields proposed by Dectris that are not currently in the
NXdetector base class are prefixed with the ``DECTRIS\_'' prefix

 
\begin{verbatim}
NXdetector (base class, version 1.1)
  acquisition_mode:NX_CHAR                        [**]
  angular_calibration:NX_FLOAT[i,j]               [**]
  angular_calibration_applied:NX_BOOLEAN          [**]
  azimuthal_angle:NX_FLOAT[np,i,j]
  beam_center_x:NX_FLOAT                          [**]
  beam_center_y:NX_FLOAT                          [**]
  bit_depth_readout:NX_UINT                       [**]
  calibration_date:NX_DATE_TIME
  countrate_correction__applied:NX_BOOLEAN        [**]
  count_time:NX_NUMBER[np]                        [**]
  crate:NX_INT[i,j] 
    @local_name
  data:NX_NUMBER[np,i,j,tof]
    @signal
    @axes
    @long_name
    @check_sum
    @link
  data_error:NX_NUMBER[np,i,j,tof]
    @units
    @link
  dead_time:NX_FLOAT[np,i,j]
  description:NX_CHAR                                  [**]
  DECTRIS_sample_detector_distance:NX_FLOAT            [**]
  detection_gas_path:NX_FLOAT
  detector_number:NX_INT[i,j]
  DECTRIS_detector_serial_number:NX_CHAR               [**]
  detector_readout_time:NX_FLOAT                       [**]
  DECTRIS_efficiency_correction_applied:NX_BOOLEAN     [**]
  diameter:NX_FLOAT
  distance:NX_FLOAT[np,i,j]
  flatfield:NX_FLOAT[i,j]
  flatfield_applied:NX_BOOLEAN                         [**]
  flatfield_error:NX_FLOAT[i,j]
  frame_start_number:NX_INT
  frame_time:NX_FLOAT[NP]                              [**]
  gain_setting:NX_CHAR                                 [**]
  gas_pressure:NX_FLOAT[i,j]
  input:NX_INT[i,j]
    @local_name
  layout:NX_CHAR
  local_name:NX_CHAR
  number_of_cycles:NX_INT                              [**]
  pixel_mask:NX_FLOAT[i,j]
  pixel_mask_applied:NX_BOOLEAN                        [**]
  polar_angle:NX_FLOAT[np,i,j]
  raw_time_of_flight:NX_INT[tof+1]
    @frequency
  saturation_value:NX_INT
  sensor_material:NX_CHAR                              [**]
  sensor_thickness:NX_FLOAT                            [**]
  sequence_number:NX_CHAR
  slot:NX_INT[i,j]
    @local_name
  solid_angle:NX_FLOAT[i,j]
  threshold_energy:NX_FLOAT                            [**]
  time_of_flight:NX_FLOAT[tof+1]
    @axis
    @primary
    @long_name
    @link
  trigger_dead_time:NX_FLOAT
  trigger_delay_time:NX_FLOAT
  type:NX_CHAR
  DECTRIS_virtual_pixel_correction_applied:NX_BOOLEAN  [**]
  x_pixel_offset:NX_FLOAT[i,j]
    @axis
    @primary
    @long_name
    @link
  x_pixel_size:NX_FLOAT[i,j]                           [**]
  y_pixel_offset:NX_FLOAT[i,j]
    @axis
    @primary
    @long_name
  y_pixel_size:NX_FLOAT[i,j]                           [**]
  characterization:NXcharacterization
  detectorSpecific:DECTRIS\_detector\_specific         [**]
  efficiency:NXdata
    efficiency:NX_FLOAT[i,j,k]
    real_time:NX_NUMBER[i,j,k]
    wavelength:NX_FLOAT[i,j,k]
  geometry:NXgeometry
  calibration_method:NXnote
  data_file:NXnote
\end{verbatim}


adding 

\begin{verbatim}
  DECTRIS_sample_detector_distance:NX_FLOAT
  DECTRIS_detector_serial_number:NX_CHAR
  DECTRIS_efficiency_correction_applied:NX_BOOLEAN 
  DECTRIS_virtual_pixel_correction_applied:NX_BOOLEAN
\end{verbatim}

and giving explicit suggested names to the NXcharacterization and NXgeometry
instances.  

\begin{verbatim}
NXdetector_detris (application definition, version 0.1)
  (overlays NXDetector)
NXdetector
  acquisition_mode:NX_CHAR
  angular_calibration_applied:NX_BOOLEAN
  beam_center_x:NX_FLOAT
    @units
  beam_center_y:NX_FLOAT
    @units
  bit_depth_readout:NX_UINT
  count_time:NX_FLOAT[np]
    @units
  countrate_correction_applied:NX_BOOLEAN
  description:NX_CHAR
  DECTRIS_sample_detector_distance:NX_FLOAT
    @units
  DECTRIS_detector_serial_number:NX_CHAR
  detector_number:NX_CHAR
  detector_readout_time:NX_FLOAT[np]
    @units
  detectorSpecific:DECTRIS_detector_specific
  DECTRIS_efficiency_correction_applied:NX_BOOLEAN
  flatfield_correction_applied:NX_BOOL
  frame_time:NX_FLOAT[np]
    @units
  gain_setting:NX_CHAR
  number_of_cycles:NX_UINT
  pixel_mask_applied:NX_BOOL
  sensor_material:NX_STRING
  sensor_thickness:NX_FLOAT
    @units
  threshold_energy:NX_FLOAT
    @units
  DECTRIS_virtual_pixel_correction_applied:NX_BOOL
  x_pixel_size:NX_FLOAT
    @units
  y_pixel_size:NX_FLOAT
    @units
\end{verbatim}

\begin{itemize}

\item{DETECTOR:NXdetector $\rightarrow$\\
\verb|  |\_NXdetector.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_NXdetector.NX\_id            DETECTOR \\
\verb|  |\_NXdetector.NX\_scan\_id      SCANID \\
\verb|  |\_NXdetector.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_NXdetector.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXdetector\_\_DETECTOR''
where DETECTOR is the name of this NeXus class instance, typically ``detector''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |acquisition\_mode:NX\_CHAR=ACQUISITION\_MODE $\rightarrow$\\
\verb|  |\_NXdetector.acquisition\_mode ACQUISITION\_MODE}

\item{\verb|  |angular\_calibration\_applied:NX\_BOOLEAN=ANGULAR\_CALIBRATION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.angular\_calibration\_applied ANGULAR\_CALIBRATION\_APPLIED}

\item{\verb|   |beam\_center\_x:NX\_FLOAT=BEAM\_CENTER\_X $\rightarrow$\\
\verb|  |\_NXdetector.beam\_center\_x BEAM\_CENTER\_X}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.beam\_center\_x\_\_units UNITS}

\item{\verb|   |beam\_center\_y:NX\_FLOAT=BEAM\_CENTER\_Y $\rightarrow$\\
\verb|  |\_NXdetector.beam\_center\_y BEAM\_CENTER\_Y}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.beam\_center\_y\_\_units UNITS}

\item{\verb|  |bit\_depth\_readout:NX\_UINT=BIT\_DEPTH\_READOUT $\rightarrow$\\
\verb|  |\_NXdetector.bit\_depth\_readout BIT\_DEPTH\_READOUT}

\item{\verb|  |count\_time:NX\_FLOAT[np]=COUNT\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.count\_time COUNT\_TIME}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.count\_time\_\_units UNITS}

\item{\verb|  |countrate\_correction\_applied:NX\_BOOLEAN=COUNTRATE\_CORRECTION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.countrate\_correction\_applied COUNTRATE\_CORRECTION\_APPLIED}

\item{\verb|  |description:NX\_CHAR=DESCRIPTION $\rightarrow$\\
\verb|  |\_NXdetector.description DESCRIPTION}

\item{\verb|   |detector\_number:NX\_CHAR=DETECTOR\_NUMBER $\rightarrow$\\
\verb|  |\_NXdetector.detector\_number DETECTOR\_NUMBER}

\item{\verb|   |detectorSpecific:DECTRIS\_detector\_specific $\rightarrow$\\
\verb|  |\_NXdetector.DECTRIS\_detector\_specific\_id  detectorSpecific}

\item{\verb|   |DECTRIS\_detector\_number:NX\_CHAR=DETECTOR\_NUMBER $\rightarrow$\\
\verb|  |\_NXdetector.DECTRIS\_detector\_number DETECTOR\_NUMBER}

\item{\verb|   |detector\_readout\_time:NX\_FLOAT[np]=DETECTOR\_READOUT\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.detector\_readout\_time DETECTOR\_READOUT\_TIME}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.detector\_readout\_time\_\_units UNITS}

\item{\verb|   |efficiency\_correction\_applied:NX\_BOOL=EFFICIENCY\_CORRECTION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.efficiency\_correction\_applied EFFICIENCY\_CORRECTION\_APPLIED}

\item{\verb|   |flatfield\_correction\_applied:NX\_BOOL=FLATFIELD\_CORRECTION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.flatfield\_correction\_applied FLATFIELD\_CORRECTION\_APPLIED}

\item{\verb|   |frame\_time:NX\_FLOAT[np]=FRAME\_TIME $\rightarrow$\\
\verb|  |\_NXdetector.frame\_time FRAME\_TIME}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.frame\_time\_\_units UNITS}

\item{\verb|   |gain\_setting:NX\_CHAR=GAIN\_SETTING $\rightarrow$\\
\verb|  |\_NXdetector.gain\_setting GAIN\_SETTING}

\item{\verb|   |number\_of\_cycles:NX\_UINT=NUMBER\_OF\_CYCLES $\rightarrow$\\
\verb|  |\_NXdetector.number\_of\_cycles NUMBER\_OF\_CYCLES}

\item{\verb|   |pixel\_mask\_applied:NX\_BOOL=PIXEL\_MASK\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.pixel\_mask\_applied PIXEL\_MASK\_APPLIED}

\item{\verb|   |sensor\_material:NX\_STRING=SENSOR\_MATERIAL $\rightarrow$\\
\verb|  |\_NXdetector.sensor\_material SENSOR\_MATERIAL}

\item{\verb|   |sensor\_thickness:NX\_FLOAT=SENSOR\_THICKNESS $\rightarrow$\\
\verb|  |\_NXdetector.sensor\_thickness SENSOR\_THICKNESS}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.sensor\_thickness\_\_units UNITS}

\item{\verb|   |threshold\_energy:NX\_FLOAT=THRESHOLD\_ENERGY $\rightarrow$\\
\verb|  |\_NXdetector.threshold\_energy THRESHOLD\_ENERGY}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.threshold\_energy\_\_units UNITS}

\item{\verb|  |DECTRIS\_virtual\_pixel\_correction\_applied:NX\_BOOL=VIRTUAL\_PIXEL\_CORRECTION\_APPLIED $\rightarrow$\\
\verb|  |\_NXdetector.DECTRIS\_virtual\_pixel\_correction\_applied VIRTUAL\_PIXEL\_CORRECTION\_APPLIED}

\item{\verb|  |x\_pixel\_size:NX\_FLOAT=X\_PIXEL\_SIZE $\rightarrow$\\
\verb|  |\_NXdetector.x\_pixel\_size X\_PIXEL\_SIZE}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.x\_pixel\_size\_\_units UNITS}

\item{\verb|  |y\_pixel\_size:NX\_FLOAT=Y\_PIXEL\_SIZE $\rightarrow$\\
\verb|  |\_NXdetector.y\_pixel\_size Y\_PIXEL\_SIZE}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_NXdetector.y\_pixel\_size\_\_units UNITS}
\end{itemize}


\subsection{detectorSpecific:DECTRIS\_detector\_specific}

These are some additions added by Dectris, that they designated as a new
detectorSpecific:DectectorSpecific NeXus class instance. 

\begin{verbatim}
DECTRIS\_detector\_specific (application definition, version 0.1)
  countrate_correction_bunch_mode:NX_CHAR
  countrate_correction_count_cutoff:NX_UINT
  countrate_correction_lookup_table:NX_FLOAT[1000000]
  data_collection_date:NX_CHAR
  detectorModule_000:DECTRIS_detector_module
  detectorModule_001:DECTRIS_detector_module
  detectorModule_002:DECTRIS_detector_module
  detectorModule_003:DECTRIS_detector_module
  detectorModule_004:DECTRIS_detector_module
  detectorModule_005:DECTRIS_detector_module
  detectorModule_006:DECTRIS_detector_module
  detectorModule_007:DECTRIS_detector_module
  detectorModule_008:DECTRIS_detector_module
  detectorModule_009:DECTRIS_detector_module
  detectorModule_010:DECTRIS_detector_module
  detectorModule_011:DECTRIS_detector_module
  detectorModule_012:DECTRIS_detector_module
  detectorModule_013:DECTRIS_detector_module
  detectorModule_014:DECTRIS_detector_module
  detectorModule_015:DECTRIS_detector_module
  detectorModule_016:DECTRIS_detector_module
  detectorModule_017:DECTRIS_detector_module
  detectorModule_018:DECTRIS_detector_module
  detectorModule_019:DECTRIS_detector_module
  detectorModule_020:DECTRIS_detector_module
  detectorModule_021:DECTRIS_detector_module
  detectorModule_022:DECTRIS_detector_module
  detectorModule_023:DECTRIS_detector_module
  detectorModule_024:DECTRIS_detector_module
  detectorModule_025:DECTRIS_detector_module
  detectorModule_026:DECTRIS_detector_module
  detectorModule_027:DECTRIS_detector_module
  detectorModule_028:DECTRIS_detector_module
  detectorModule_029:DECTRIS_detector_module
  detectorModule_030:DECTRIS_detector_module
  detectorModule_031:DECTRIS_detector_module
  detectorModule_032:DECTRIS_detector_module
  detectorModule_033:DECTRIS_detector_module
  detectorModule_034:DECTRIS_detector_module
  detectorModule_035:DECTRIS_detector_module
  detectorModule_036:DECTRIS_detector_module
  detectorModule_037:DECTRIS_detector_module
  detectorModule_038:DECTRIS_detector_module
  detectorModule_039:DECTRIS_detector_module
  detectorModule_040:DECTRIS_detector_module
  detectorModule_041:DECTRIS_detector_module
  detectorModule_042:DECTRIS_detector_module
  detectorModule_043:DECTRIS_detector_module
  detectorModule_044:DECTRIS_detector_module
  detectorModule_045:DECTRIS_detector_module
  detectorModule_046:DECTRIS_detector_module
  detectorModule_047:DECTRIS_detector_module
  detectorModule_048:DECTRIS_detector_module
  detectorModule_049:DECTRIS_detector_module
  detectorModule_050:DECTRIS_detector_module
  detectorModule_051:DECTRIS_detector_module
  detectorModule_052:DECTRIS_detector_module
  detectorModule_053:DECTRIS_detector_module
  detectorModule_054:DECTRIS_detector_module
  detectorModule_055:DECTRIS_detector_module
  detectorModule_056:DECTRIS_detector_module
  detectorModule_057:DECTRIS_detector_module
  detectorModule_058:DECTRIS_detector_module
  detectorModule_059:DECTRIS_detector_module
  detector_origin:NX_FLOAT
      @depends_on
      @transformation
      @units
      @vector
  transformLabToDetector:NX_FLOAT
      @rotation:NX_FLOAT[9]
      @translation:NX_FLOAT[3]
      @units
  flat field:NX_FLOAT[number of x pixels,number of y pixels]
  mode_register:NX_UINT
  nimages:NX_UINT
  number_of_excluded_pixels:NX_UINT
  photon_energy:NX_FLOAT
  pixel_mask:NX_UINT[number of x pixels,number of y pixels]
  readout_mode:NX_CHAR
  software_version:NX_CHAR
  sub_image_exposure_time:NX_FLOAT
  summation_mode:NX_CHAR
  summation_nimages:NX_UINT
  trigger_mode:NX_CHAR
  x_pixels_in_detector:NX_UINT
  y_pixels_in_detector:NX_UINT
\end{verbatim}

\begin{itemize}

\item{DETECTOR\_SPECIFIC:DECTRIS\_detector\_specific $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_DECTRIS\_detector\_specific.NX\_id            DETECTOR\_SPECIFIC \\
\verb|  |\_DECTRIS\_detector\_specific.NX\_scan\_id      SCANID \\
\verb|  |\_DECTRIS\_detector\_specific.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_DECTRIS\_detector\_specific.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/NXcollection- \_\_\_DETECTOR\_SPECIFIC''
where \_DETECTOR\_SPECIFIC is the name of this NeXus class instance, typically ``collection''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |countrate\_correction\_bunch\_mode:NX\_CHAR=COUNTRATE\_CORRECTION\_BUNCH\_MODE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.countrate\_correction\_bunch\_mode \\
\verb|    |COUNTRATE\_CORRECTION\_BUNCH\_MODE}

\item{\verb|  |countrate\_correction\_count\_cutoff:NX\_UINT=\\
\verb|    |COUNTRATE\_CORRECTION\_COUNT\_CUTOFF $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.countrate\_correction\_count\_cutoff \\
\verb|    |COUNTRATE\_CORRECTION\_COUNT\_CUTOFF}

\item{\verb|  |countrate\_correction\_lookup\_table:NX\_FLOAT[1000000]\\
\verb|    |=COUNTRATE\_CORRECTION\_LOOKUP\_TABLE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.countrate\_correction\_lookup\_table \\
\verb|    |COUNTRATE\_CORRECTION\_LOOKUP\_TABLE}

\item{\verb|  |data\_collection\_date:NX\_CHAR=DATA\_COLLECTION\_DATE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.data\_collection\_date DATA\_COLLECTION\_DATE}

\item{detectorModule\_000:DECTRIS\_detector\_module \\
detectorModule\_001:DECTRIS\_detector\_module\\
... \\
detectorModule\_059:DECTRIS\_detector\_module $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.DECTRIS\_detector\_module\_id\\
\verb|    |["detectorModule\_000","detectorModule\_001",...,"detectorModule\_059"]}

\item{\verb|  |detector\_origin:NX\_FLOAT64=DETECTOR\_ORIGIN $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.detector\_origin DETECTOR\_ORIGIN}

\item{\verb|      |@depends\_on=DEPENDS\_ON $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.detector\_origin\_\_depends\_on DEPENDS\_ON}

\item{\verb|      |@transformation=TRANSFORMATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.detector\_origin\_\_transformation TRANSFORMATION}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.detector\_origin\_\_units UNITS}

\item{\verb|      |@vector=VECTOR $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.detector\_origin\_\_vector VECTOR}

\item{\verb|  |transformLabToDetector:NX\_FLOAT64=TRANSFORMLABTODETECTOR $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.transformLabToDetector TRANSFORMLABTODETECTOR}

\item{\verb|      |@rotation=ROTATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.transformLabToDetector\_\_rotation ROTATION}

\item{\verb|      |@translation=TRANSLATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.transformLabToDetector\_\_translation TRANSLATION}

\item{\verb|      |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_specific.transformLabToDetector\_\_units UNITS}

\item{\verb|  |flatfield:NX\_FLOAT[numberofxpixels,numberofypixels]=FLATFIELD $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.flatfield FLATFIELD}

\item{\verb|  |mode\_register:NX\_UINT=MODE\_REGISTER $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.mode\_register MODE\_REGISTER}

\item{\verb|  |nimages:NX\_UINT=NIMAGES $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.nimages NIMAGES}

\item{\verb|  |number\_of\_excluded\_pixels:NX\_UINT=NUMBER\_OF\_EXCLUDED\_PIXELS $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.number\_of\_excluded\_pixels NUMBER\_OF\_EXCLUDED\_PIXELS}

\item{\verb|  |photon\_energy:NX\_FLOAT=PHOTON\_ENERGY $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.photon\_energy PHOTON\_ENERGY}

\item{\verb|  |pixel\_mask:NX\_UINT[numberofxpixels,numberofypixels]=PIXEL\_MASK $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.pixel\_mask PIXEL\_MASK}

\item{\verb|  |readout\_mode:NX\_CHAR=READOUT\_MODE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.readout\_mode READOUT\_MODE}

\item{\verb|  |software\_version:NX\_CHAR=SOFTWARE\_VERSION $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.software\_version SOFTWARE\_VERSION}

\item{\verb|  |sub\_image\_exposure\_time:NX\_FLOAT=SUB\_IMAGE\_EXPOSURE\_TIME $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.sub\_image\_exposure\_time SUB\_IMAGE\_EXPOSURE\_TIME}

\item{\verb|  |summation\_mode:NX\_CHAR=SUMMATION\_MODE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.summation\_mode SUMMATION\_MODE}

\item{\verb|  |summation\_nimages:NX\_UINT=SUMMATION\_NIMAGES $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.summation\_nimages SUMMATION\_NIMAGES}

\item{\verb|  |trigger\_mode:NX\_CHAR=TRIGGER\_MODE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.trigger\_mode TRIGGER\_MODE}

\item{\verb|  |x\_pixels\_in\_detector:NX\_UINT=X\_PIXELS\_IN\_DETECTOR $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.x\_pixels\_in\_detector X\_PIXELS\_IN\_DETECTOR}

\item{\verb|  |y\_pixels\_in\_detector:NX\_UINT=Y\_PIXELS\_IN\_DETECTOR $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_specific.y\_pixels\_in\_detector Y\_PIXELS\_IN\_DETECTOR}
\end{itemize}

The specific number of modules may vary.

\subsection{detectorModule\_nnn:DECTRIS\_detector\_module}

\begin{verbatim}
DECTRIS\_detector\_module (application definition, version 0.1)
  dac_names:NX_CHAR[6]
  dac_values:NX_UINT[6]
  data_origin:NX_UINT[2]
  data_size:NX_UINT[2]
  detectorChip_000:DECTRIS_detector_chip
  detectorChip_001:DECTRIS_detector_chip
  detectorChip_002:DECTRIS_detector_chip
  detectorChip_003:DECTRIS_detector_chip
  detectorChip_004:DECTRIS_detector_chip
  detectorChip_005:DECTRIS_detector_chip
  detectorChip_006:DECTRIS_detector_chip
  detectorChip_007:DECTRIS_detector_chip
  detectorChip_008:DECTRIS_detector_chip
  detectorChip_009:DECTRIS_detector_chip
  detectorChip_010:DECTRIS_detector_chip
  detectorChip_011:DECTRIS_detector_chip
  detectorChip_012:DECTRIS_detector_chip
  detectorChip_013:DECTRIS_detector_chip
  detectorChip_014:DECTRIS_detector_chip
  detectorChip_015:DECTRIS_detector_chip
  fast_pixel_direction:NX_FLOAT64
    @depends_on
    @transformation
    @units
    @vector
  firmware_version:NX_CHAR
  module_offset:NX_FLOAT64
    @depends_on
    @transformation
    @units
    @vector
  nbits:NX_UINT
  nchips:NX_UINT
  readout_frequency:NX_FLOAT
    @units
  region_of_interest:NX_UINT[4]
  slow_pixel_direction:NX_FLOAT64
    @depends_on
    @transformation
    @units
    @vector
  x_pixels_in_module:NX_UINT
  y_pixels_in_module:NX_UINT
\end{verbatim}

\begin{itemize}

\item{DETECTORMODULE:DECTRIS\_detector\_module $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_DECTRIS\_detector\_module.NX\_id            DETECTORMODULE\\
\verb|  |\_DECTRIS\_detector\_module.NX\_scan\_id      SCANID \\
\verb|  |\_DECTRIS\_detector\_module.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_DECTRIS\_detector\_module.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/DECTRIS\_detector\_module- \_\_DETECTORMODULE''
where DETECTORMODULE is the name of this NeXus class instance, typically ``detectorModule\_nnn''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |dac\_names:NX\_CHAR[6]=DAC\_NAMES $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.dac\_names DAC\_NAMES}

\item{\verb|  |dac\_values:NX\_UINT[7]=DAC\_VALUES $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.dac\_values DAC\_VALUES}

\item{\verb|  |data\_origin:NX\_UINT[2]=DATA\_ORIGIN $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.data\_origin DATA\_ORIGIN}

\item{\verb|  |data\_size:NX\_UINT[2]=DATA\_SIZE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.data\_size DATA\_SIZE}

\item{detectorChip\_000:DECTRIS\_detector\_chip \\
detectorChip\_001:DECTRIS\_detector\_chip \\
... \\
detectorChip\_015:DECTRIS\_detector\_chip $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.NXcollection\_id \\
\verb|    |["detectorChip\_000","detectorChip\_001",...,"detectorChip\_015"]}

\item{\verb|  |fast\_pixel\_direction:NX\_FLOAT64=FAST\_PIXEL\_DIRECTION $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.fast\_pixel\_direction FAST\_PIXEL\_DIRECTION}

\item{\verb|    |@depends\_on=DEPENDS\_ON $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.fast\_pixel\_direction\_\_depends\_on DEPENDS\_ON}

\item{\verb|    |@transformation=TRANSFORMATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.fast\_pixel\_direction\_\_transformation TRANSFORMATION}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.fast\_pixel\_direction\_\_units UNITS}

\item{\verb|    |@vector=VECTOR $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.fast\_pixel\_direction\_\_vector VECTOR}

\item{\verb|  |firmware\_version:NX\_CHAR=FIRMWARE\_VERSION $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.firmware\_version FIRMWARE\_VERSION}

\item{\verb|  |module\_offset:NX\_FLOAT64=MODULE\_OFFSET $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.module\_offset MODULE\_OFFSET}

\item{\verb|    |@depends\_on=DEPENDS\_ON $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.module\_offset\_\_depends\_on DEPENDS\_ON}

\item{\verb|    |@transformation=TRANSFORMATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.module\_offset\_\_transformation TRANSFORMATION}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.module\_offset\_\_units UNITS}

\item{\verb|    |@vector=VECTOR $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.module\_offset\_\_vector VECTOR}

\item{\verb|  |nbits:NX\_UINT=NBITS $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.nbits NBITS}

\item{\verb|  |nchips:NX\_UINT=NCHIPS $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.nchips NCHIPS}

\item{\verb|  |readout\_frequency:NX\_FLOAT=READOUT\_FREQUENCY $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.readout\_frequency READOUT\_FREQUENCY}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.readout\_frequency\_\_units UNITS}

\item{\verb|  |region\_of\_interest:NX\_UINT[4]=REGION\_OF\_INTEREST $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.region\_of\_interest REGION\_OF\_INTEREST}

\item{\verb|  |slow\_pixel\_direction:NX\_FLOAT64=SLOW\_PIXEL\_DIRECTION $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.slow\_pixel\_direction SLOW\_PIXEL\_DIRECTION}

\item{\verb|    |@depends\_on=DEPENDS\_ON $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.slow\_pixel\_direction\_\_depends\_on DEPENDS\_ON}

\item{\verb|    |@transformation=TRANSFORMATION $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.slow\_pixel\_direction\_\_transformation TRANSFORMATION}

\item{\verb|    |@units=UNITS $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.slow\_pixel\_direction\_\_units UNITS}

\item{\verb|    |@vector=VECTOR $\rightarrow$\\
\verb|    |\_DECTRIS\_detector\_module.slow\_pixel\_direction\_\_vector VECTOR}

\item{\verb|  |x\_pixels\_in\_module:NX\_UINT=X\_PIXELS\_IN\_MODULE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.x\_pixels\_in\_module X\_PIXELS\_IN\_MODULE}

\item{\verb|  |y\_pixels\_in\_module:NX\_UINT=Y\_PIXELS\_IN\_MODULE $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_module.y\_pixels\_in\_module Y\_PIXELS\_IN\_MODULE}
\end{itemize}

The specific number of chips may vary.

\subsection{detectorChip\_nn:DECTRIS\_detector\_chip}

\begin{verbatim}
DECTRIS_detector_chip
  chip_type:NX_CHAR
  x_pixels_in_chip:NX_UINT
  x_position:NX_UINT
  y_pixels_in_chip:NX_UINT
  y_position:NX_UINT
\end{verbatim}

\begin{itemize}

\item{DETECTORCHIP:DECTRIS\_detector\_chip $\rightarrow$\\
\verb|  |\_DECTRIS\_detector\_chip.NX\_tree\_path    NEXUSTREEPATH \\
\verb|  |\_DECTRIS\_detector\_chip.NX\_id            DETECTORCHIP\\
\verb|  |\_DECTRIS\_detector\_chip.NX\_scan\_id      SCANID \\
\verb|  |\_DECTRIS\_detector\_chip.NX\_diffrn\_id    DIFFRNID \\
\verb|  |\_DECTRIS\_detector\_chip.NX\_entry\_id     ENTRYID \\
where components of NEXUSTREEPATH are composed of the
relevant NeXus class, a double under score and, finally, the
name of the NeXus class instance, ending with ``/DECTRIS\_detector\_chip- \\
\_\_DETECTORCHIP''
where DETECTORCHIP is the name of this NeXus class instance, typically ``detectorChip\_nnn''.
The SCANID, DIFFRNID and ENTRYID are optional keys for use
when multiple scans, {\it etc.} are aggregated in the same CBF.}

\item{\verb|  |chip\_type:NX\_CHAR=CHIP\_TYPE $\rightarrow$\\
\verb|  |\_NXcollection.chip\_type CHIP\_TYPE}

\item{\verb|  |x\_pixels\_in\_chip:NX\_UINT=X\_PIXELS\_IN\_CHIP $\rightarrow$\\
\verb|  |\_NXcollection.x\_pixels\_in\_chip X\_PIXELS\_IN\_CHIP}

\item{\verb|  |x\_position:NX\_UINT=X\_POSITION $\rightarrow$\\
\verb|  |\_NXcollection.x\_position X\_POSITION}

\item{\verb|  |y\_pixels\_in\_chip:NX\_UINT=Y\_PIXELS\_IN\_CHIP $\rightarrow$\\
\verb|  |\_NXcollection.y\_pixels\_in\_chip Y\_PIXELS\_IN\_CHIP}

\item{\verb|  |y\_position:NX\_UINT=Y\_POSITION $\rightarrow$\\
\verb|  |\_NXcollection.y\_position Y\_POSITION}
\end{itemize}

\subsection{Consolidated Dectris Eiger Application Definition}

In addition to the above classes, the Dectris application definition draws
on NXsample for the rotation\_angle\_step and NXmonochromator for the wavelength.
The Dectris Eiger NeXus format as proposed by Dectris with the proposed changes
in this document marked with ``**[ ... ]**'' is as follows.  However,
rotation\_angle\_step is not in the NeXus base class dictionary.  Therefore,
we flag it with the DETRIS prefix until it is formally adopted as part of
the NXsample base class.

\footnotesize{\begin{verbatim}
NXdectris_eiger (application definition, version 0.1)
  (overlays NXentry)
  entry:NXentry
    data_000001:NXDATA
      data:NXINT[np_000001,number of x pixels,number of y pixels]
        @image_nr_low
        @image_nr_high
    data_000002:NXDATA
      data:NXINT[np_000001,number of x pixels,number of y pixels]
        @image_nr_low
        @image_nr_high
    ...
    data_nnnnnn:NXDATA
      data:NXINT[np_nnnnnn,number of x pixels,number of y pixels]
        @image_nr_low
        @image_nr_high
    instrument:NXinstrument
      detector:NXdetector
        acquisition_mode:NX_CHAR
        angular_calibration_applied:NX_FLOAT32[number of x pixels,number of y pixels]
        beam_center_x:NX_FLOAT
          @units
        beam_center_y:NX_FLOAT
          @units
        bit_depth_readout:NX_UINT
        countrate_correction_applied:NX_BOOLEAN
        count_time:NX_FLOAT[np]
          @units
        description:NX_CHAR
        detector_number:NX_CHAR
        detectorSpecific:DetectorSpecific           **[detectorSpecific:DECTRIS_detector_specific]**
          countrate_correction_bunch_mode:NX_CHAR
          countrate_correction_count_cutoff:NX_UINT
          countrate_correction_lookup_table:NX_FLOAT[1000000]
          data_collection_date:NX_CHAR
          detectorModule_000:detectorModule         **[detectorModule_000:DECTRIS_detector_module]**
            dac_names:NX_CHAR[6]
            dac_values:NX_UINT[7]
            data_origin:NX_UINT[2]
            data_size:NX_UINT[2]
            detectorChip_000:DetectorChip            **[detectorChip_000:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            detectorChip_001:DetectorChip            **[detectorChip_001:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            ...  
            detectorChip_015:DetectorChip            **[detectorChip_015:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            fast_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            firmware_version:NX_CHAR
            module_offset:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            nbits:NX_UINT
            nchips:NX_UINT
            readout_frequency:NX_FLOAT
              @units
            region_of_interest:NX_UINT[4]
            slow_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            x_pixels_in_module:NX_UINT
            y_pixels_in_module:NX_UINT
          detectorModule_001:detectorModule         **[detectorModule_001:DECTRIS_detector_module]**
            dac_names:NX_CHAR[6]
            dac_values:NX_UINT[7]
            data_origin:NX_UINT[2]
            data_size:NX_UINT[2]
            detectorChip_000:DetectorChip            **[detectorChip_000:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            detectorChip_001:DetectorChip            **[detectorChip_001:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            ...  
            detectorChip_015:DetectorChip            **[detectorChip_015:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            fast_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            firmware_version:NX_CHAR
            module_offset:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            nbits:NX_UINT
            nchips:NX_UINT
            readout_frequency:NX_FLOAT
              @units
            region_of_interest:NX_UINT[4]
            slow_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            x_pixels_in_module:NX_UINT
            y_pixels_in_module:NX_UINT
           ...
           detectorModule_059:detectorModule        **[detectorModule_059:DECTRIS_detector_module]**
            dac_names:NX_CHAR[6]
            dac_values:NX_UINT[7]
            data_origin:NX_UINT[2]
            data_size:NX_UINT[2]
            detectorChip_000:DetectorChip            **[detectorChip_000:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            detectorChip_001:DetectorChip            **[detectorChip_001:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            ...  
            detectorChip_015:DetectorChip            **[detectorChip_015:DECTRIS_detector_chip]**
              chip_type:NX_CHAR
              x_pixels_in_chip:NX_UINT
              x_position:NX_UINT
              y_pixels_in_chip:NX_UINT
              y_position:NX_UINT
            fast_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            firmware_version:NX_CHAR
            module_offset:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            nbits:NX_UINT
            nchips:NX_UINT
            readout_frequency:NX_FLOAT
              @units
            region_of_interest:NX_UINT[4]
            slow_pixel_direction:NX_FLOAT
              @transformation
              @vector:NX_FLOAT[3]
              @units
              @depends_on
            x_pixels_in_module:NX_UINT
            y_pixels_in_module:NX_UINT
          detector_origin:NX_FLOAT
            @transformation
            @vector:NX_FLOAT[3]
            @units
            @depends_on
          transformLabToDetector:NX_FLOAT
            @rotation:NX_FLOAT[9]
            @translation:NX_FLOAT[3]
            @units
          flatfield:NX_FLOAT[number of x pixels,number of y pixels]
          mode_register:NX_UINT
          nimages:NX_UINT
          number_of_excluded_pixels:NX_UINT
          photon_energy:NX_FLOAT
          pixel_mask:NX_UINT[number of x pixels,number of y pixels]
          readout_mode:NX_CHAR
          software_version:NX_CHAR
          sub_image_exposure_time:NX_FLOAT
          summation_mode:NX_CHAR
          summation_nimages:NX_UINT
          trigger_mode:NX_CHAR
          x_pixels_in_detector:NX_UINT
          y_pixels_in_detector:NX_UINT
        detector_number:NX_CHAR
        detector_readout_time:NX_FLOAT[np]
          @units
        efficiency_correction_applied:NX_BOOL
        flatfield_correction_applied:NX_BOOL
        frame_time:NX_FLOAT[np]
          @units
        gain_setting:NX_CHAR
        number_of_cycles:NX_UINT
        pixel_mask_applied:NX_BOOL
        sensor_material:NX_STRING
        sensor_thickness:NX_FLOAT
          @units
        threshold_energy:NX_FLOAT
          @units
        virtual_pixel_correction_applied:NX_BOOLEAN
        x_pixel_size:NX_FLOAT
          @units
        y_pixel_size:NX_FLOAT
          @units
    sample:NXsample
      rotation_angle_step:NX_FLOAT[np]                    **[DECTRIS_rotation_angle_step]**
        @units
    monochromator:NXmonchromator
      wavelength:NX_FLOAT32
        @units
\end{verbatim}}

\bibliographystyle{plain}
\bibliography{NeXus_CBF_Concordance_Summary.bib}


\end{document}  